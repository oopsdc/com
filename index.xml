<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Atmet</title>
    <link>https://oopsdc.tk/</link>
    <description>Recent content on Atmet</description>
    <image>
      <url>https://oopsdc.tk/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://oopsdc.tk/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 17 Jun 2021 09:03:30 +0800</lastBuildDate><atom:link href="https://oopsdc.tk/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>漏洞复现</title>
      <link>https://oopsdc.tk/post/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</link>
      <pubDate>Thu, 17 Jun 2021 09:03:30 +0800</pubDate>
      
      <guid>https://oopsdc.tk/post/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</guid>
      <description>Web漏洞 Apache Airflow 存储型XSS 漏洞描述 Apache Airflow 1.10.2及之前版本中的airflow webserver服务存在跨站脚本漏洞，该漏洞源于WEB应用缺少对客户端数据的正确验证，使得攻击者可利用该漏洞执行客户端代码。
影响版本 Apache Airflow 1.10.3以下版本。
复现思路 漏洞复现 访问/admin/dagrun/(默认不需要密码)
创建一个项目，输入ID后点击保存，返回列表，点击running字样，发现能够输入HTML代码，例:
&amp;lt;script&amp;gt;_a=&amp;#34;https://www.baidu.com&amp;#34;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt;document.location=_a&amp;lt;/script&amp;gt; 能直接造成存储型XSS。
ActiveMQ 反序列化漏洞 CVE-2015-5254 漏洞描述 Apache ActiveMQ是Apache软件经济会研发的一套开源消息中间件，支持Java消息服务、集群、Spring Framework等。Apache ActiveMQ 5.13.0之前版本，即5.x版本中存在反序列化漏洞，该漏洞源于程序没有限制可在代理中序列化的类，攻击者可借助特制的序列化Java消息服务(JMS) ObjectMessage对象利用该漏洞执行任意代码。
影响版本 Apache ActiveMQ 5.13.0之前的5.x版本。
复现思路 1.构造(可使用ysoserial)可执行命令的序列化对象。
2.作为一个消息，发送给目标61616端口。
3.访问web管理页面，读取消息，触发漏洞。
漏洞复现 使用jmet进行漏洞利用:https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar
 下载好之后在jmet-0.1.0-all.jar同级目录下创建external文件夹，避免出现文件夹不存在的报错。
jmet的原理是使用jar包内置ysoserial生成Payload并发送，我们需要在ysoserial的gadget选择一个可使用的，如ROME。
 给目标ActiveMQ添加一个名为event的队列，点击事件为生成/tmp/vuln文件:
java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &amp;#34;touch /tmp/vuln&amp;#34; -Yp ROME &amp;lt;ip&amp;gt; 61616 # 命令执行成功后回显如下 INFO d.c.j.t.JMSTarget [main] Connected with ID: ID:&amp;lt;server-id&amp;gt; INFO d.</description>
    </item>
    
    <item>
      <title>博客搭建</title>
      <link>https://oopsdc.tk/post/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sat, 12 Jun 2021 12:29:53 +0800</pubDate>
      
      <guid>https://oopsdc.tk/post/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid>
      <description>博客搭建 hugo Hugo官方网站:https://gohugo.io
本文以PaperMod主题为例，官方文档:Installation · adityatelange/hugo-PaperMod Wiki (github.com)
需求准备 Hugo:Releases · gohugoio/hugo (github.com)
安装步骤 1.解压压缩包 2.配置环境变量 D:\Env\hugo_0.83.13.初始化博客 官方文档推荐我们使用易读性更高的yml格式初始化博客。
hugo new site &amp;lt;name of site&amp;gt; -f yml4.指定主题 在config.yml文件中设置主题。
theme: PaperMod5.本地启动 先在本地看看网站跑起来的效果
hugo server6.创建GitHub仓库 具体操作详见之后的hexo主题教学。
7.修改baseUrl 将config.yml文件中的baseUrl修改为刚刚创建的仓库。
baseURL: &amp;quot;https://&amp;lt;username&amp;gt;.github.io/&amp;quot;8.生成public文件夹 public中包含所有静态页面的内容，我们需要生成这个文件夹并上传到远程仓库中，完成博客部署。
hugo9.push到远程仓库 # 配置代理 git config --global http.proxy socks5://127.0.0.1:port git config --global https.proxy socks5://127.0.0.1:port # 更改默认分支 git push -u origin main # push文件 cd public git init git add .</description>
    </item>
    
    <item>
      <title>XSS Challenges</title>
      <link>https://oopsdc.tk/post/xss-challenges/</link>
      <pubDate>Thu, 10 Jun 2021 21:03:39 +0800</pubDate>
      
      <guid>https://oopsdc.tk/post/xss-challenges/</guid>
      <description>题目地址：https://xss-quiz.int21h.jp/
Stage #1 Hint: Very simple&amp;hellip;
直接输入测试语句：
Stage #2 Hint: Close the current tag and add SCRIPT tag&amp;hellip;
上测试语句：
然后审查元素，只需要把input标签闭合就能执行我们的语句了。
&amp;ldquo;&amp;gt;alert(document.domain);Stage #3 Hint: The input in text box is properly escaped.
这个页面有两个input标签，先在搜索框输入我们的测试语句试试。
直接把我们的语句放到标签里了，但是这旁边不是还有一个input标签吗。把两者的name互换一下即可。
Stage #4 Hint: Invisible input field.
审查元素发现有三个input标签，第三个标签的属性是hidden，这里把它改为text，然后把input标签闭合，之后放上我们的语句即可。
&amp;ldquo;&amp;gt;alert(document.domain);Stage #5 Hint: Length limited text box.
审查元素，发现搜索框的长度被限制，修改maxlength的值即可。
&amp;ldquo;&amp;gt;alert(document.domain);Stage #6 Hint: Event handler attributes.
输入测试语句：
&amp;ldquo;&amp;gt;alert(document.domain);发现尖括号和斜杠被转义了，那我们就使用不带尖括号的语句。
&amp;lsquo;&amp;rdquo; onload=&amp;ldquo;alert(document.domain);&amp;quot;&amp;rsquo;
Stage #7 Hint:Nearly the same&amp;hellip; but a bit more tricky.
审查元素，发现Hint元素旁边有一个隐藏的输入框，将其属性修改为text，并将value设置如下：
‘”onmouseover=&amp;ldquo;alert(document.domain);&amp;quot;&#39;</description>
    </item>
    
    <item>
      <title>Test</title>
      <link>https://oopsdc.tk/post/test/</link>
      <pubDate>Fri, 28 May 2021 21:03:39 +0800</pubDate>
      
      <guid>https://oopsdc.tk/post/test/</guid>
      <description>He11o, th1s 1s a test!
#include &amp;lt;stdio.h&amp;gt;int main() { pritnf(&amp;#34;Hello World!&amp;#34;); } </description>
    </item>
    
    <item>
      <title>网站镜像克隆</title>
      <link>https://oopsdc.tk/post/%E7%BD%91%E7%AB%99%E9%95%9C%E5%83%8F%E5%85%8B%E9%9A%86/</link>
      <pubDate>Tue, 20 Apr 2021 22:06:50 +0800</pubDate>
      
      <guid>https://oopsdc.tk/post/%E7%BD%91%E7%AB%99%E9%95%9C%E5%83%8F%E5%85%8B%E9%9A%86/</guid>
      <description>使用wget克隆网站 使用方法 我们可以使用man wget命令查看帮助文档。
操作命令及参数解释如下：
wget -m -p -E -k -K -np -v https://www.baidu.com/ # 参数解释 -m	:	镜像，选择该选项适用于Web站点 -p	:	页面获取的先决条件，该选项确保包含了请求的图片和css脚本文件被下载(可以更好复制html5站点) -E	:	适用于拓展，可以在本地另存一个html文件 -k	:	转换链接，确保文件本转换，适用于本地浏览 -K	:	转换备份文件，将以orig为后缀作为原始文件 -np	:	不要到上一层子目录中 -v	:	显示过程，不显示过程为-nv 克隆结果 # 克隆后在当前目录下会出现一个与网站同名的子目录，树形结构如下 www.baidu.com ├── index.html ├── index.html.orig └── robots.txt 0 directories, 3 files 使用HTTrack克隆网站 使用方法 httrack # 进入软件后需要输入项目名 baidu # 克隆后的存放地址 /home/oopsdc/Desktop # 要克隆的网站地址 www.baidu.com # 有6个选项，此处我们选2，具有向导递归层级的镜像网站 2 # 接下来的部分全选默认选项 默认回车 克隆结果 baidu ├── backblue.</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://oopsdc.tk/post/docker/</link>
      <pubDate>Tue, 13 Apr 2021 22:06:50 +0800</pubDate>
      
      <guid>https://oopsdc.tk/post/docker/</guid>
      <description>Docker概述 镜像(image)：
一个只读模板。一个镜像可以用来创建多个Docker容器，好似Java中的类和对象，镜像是类，容器是对象。容器(container)：
Docker利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。容器可以被启动、开始、停止、删除。每个容器都是相互个隔离的。也可以把容器看做一个简易版Linux环境(包括root用户权限、进程空间、用户空间和网络空间等)及运行在其中的应用程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器最上面一层可读可写。仓库(repository)：
仓库是集中存放镜像文件的场所。仓库和仓库注册服务器(registry)是有区别的，后者往往存在多个仓库，每个仓库又存在多个镜像，每个镜像有不同的标签。仓库分为公开仓库和私有仓库两种形式。最大的公开仓库是Docker Hub，国内最大的为阿里云、网易云等。Docker安装  环境：CentOS 7
 1.官方文档
2.yum安装gcc相关环境
yum -y install gcc yum -y install gcc-c++ 3.卸载旧版本
yum remove docker \ 	docker-client \ 	docker-client-latest \ 	docker-common \ 	docker-latest \ 	docker-latest-logrotate \ 	docker-logrotate \ 	docker-engine 4.安装依赖包
yum install -y yum-utils 5.设置镜像仓库
# 错误 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo ## 报错 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout # 推荐国内镜像 yum-config-manager --add-repo http://mirrors.</description>
    </item>
    
    <item>
      <title>Go</title>
      <link>https://oopsdc.tk/post/go/</link>
      <pubDate>Tue, 13 Apr 2021 22:06:50 +0800</pubDate>
      
      <guid>https://oopsdc.tk/post/go/</guid>
      <description>runoob教程：https://www.runoob.com/go/go-tutorial.html
环境搭建 安装包官方下载地址：https://golang.org/dl/
国内能打开的地址：https://golang.google.cn/dl/
Windows安装go 安装包下载 这里我选择下载msi文件上面的go1.16.2.windows-amd64.zip压缩包，然后放在环境目录D:\Env\go1.16.2\bin下解压。
环境配置 将go目录下的/bin路径添加到Path环境变量中，点击新建。
检测安装 打开cmd输入go。
hello-world 在工作目录创建hello.go文件。
package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;Hello, World!&amp;#34;) } 使用go run命令运行：
go run hello.go go build生成二进制文件运行：
&amp;gt; go build .\hello.go &amp;gt; ls Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2021/3/15 10:50 2094592 hello.exe -a---- 2021/3/15 10:47 79 hello.go &amp;gt; .\hello.exe Hello, World! Linux安装go 环境：Ubuntu 20.04.1(推荐使用WSL，但现在电脑上没配置，就在虚拟机上做了)
官方安装文档：https://golang.google.cn/doc/install?download=go1.16.2.linux-amd64.tar.gz
安装包下载 下载go1.16.2.linux-amd64.tar.gz压缩文件。
解压 $ sudo tar -zxvf go1.16.2.linux-amd64.tar.gz 设置环境变量 $ export PATH=$PATH:/usr/local/go/bin 检测安装 $ go version 问题处理 本来想通过VMware Tools把压缩文件直接从主机拖到虚拟机的，但尝试本地解压VMware Tools失败，报错显示内存不足，尝试解压到其它目录。解决方法如下：</description>
    </item>
    
    <item>
      <title>GTK&#43;</title>
      <link>https://oopsdc.tk/post/gtk&#43;/</link>
      <pubDate>Sat, 27 Mar 2021 22:06:50 +0800</pubDate>
      
      <guid>https://oopsdc.tk/post/gtk&#43;/</guid>
      <description>GTK+简介 GTK+(Gnome Toolkit+)最初是为GIMP(GNU Image Manipulation Program)写的，在开发早期GIMP版本时，Peter Mattis 和 Spencer Kimball创建了GTK(GIMP Toolkit)作为Motif收费工具包的替代。当GTK获得了面向对象特性和可扩展性后，才变为了GTK+。
GTK+特点 稳定、跨平台、多语言绑定、接口丰富、与时俱进、算法丰富、移动嵌入式应用广泛.
学习手册  GTK+2手册：https://developer.gnome.org/gtk2/ GTK+3手册：https://developer.gnome.org/gtk3/ 中文手册：https://www.bookstack.cn/read/GTK-3-Chinese-Reference-Manual/README.md  GTK程序简介  使用gcc编译时加上pkg-config --cflags --libs gtk+-2.0，或者直接使用makefile编译
 例： gcc demo.c -o demo `pkg-config --cflags --libs gtk+-2.0` 自动获得预处理参数，如宏定义、头文件位置 自动获得链接参数，如库、依赖库位置、文件名及其它参数 GTK程序基本框架 #include &amp;lt;gtk/gtk.h&amp;gt; int main(int argc, char *argv[]) { gtk_init(&amp;amp;argc, &amp;amp;argv);	// 初始化  // 代码区  gtk_main();	// 主事件循环  return 0; } 分析：
&amp;lt;gtk/gtk.h&amp;gt;	// 头文件，包括了GTK+所有控件、变量、函数和结构的声明 gtk_init()	// 必须在控件定义之前使用，参数由命令中解析出来并送到程序中。主要作用为设立GTK+运行环境，自动完成一些必要的初始化工作 gtk_main()	// 程序运行停在这里等待事件(如键盘或鼠标事件)的发生，等待用户操作窗口。这个函数在所有GTK+程序中都要调用 GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL)	// GtkWidget是GTK+控件类型，GtkWidget*能指向任何控件的指针类型 gtk_window_new()	// 创建一个窗口并返回这个窗口的控件指针 GTK_WINDOW_TOPLEVEL	// 指明窗口类型为最上层主窗口 gtk_widget_show(window)	// 显示上一步创建的窗口控件  控件介绍</description>
    </item>
    
    <item>
      <title>SQL注入</title>
      <link>https://oopsdc.tk/post/sql%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Mon, 07 Dec 2020 22:06:50 +0800</pubDate>
      
      <guid>https://oopsdc.tk/post/sql%E6%B3%A8%E5%85%A5/</guid>
      <description>SQL注入 规则 通过发送异常数据来触发异常。
规则含义 识别Web应用上所有的数据输入，了解哪种类型的请求会触发异常，检测服务器响应中的异常。
Web应用通常包含：表示层、逻辑层、数据层。
SQL注入分类 有参数传递。
参数带入数据库查询且执行。
产生过程 web应用开发人员无法确保在将从web表单、cookie、输入参数等收到的值传递给SQL查询之前已对其进行验证，则通常会引起SQL注入。
若攻击者能够控制发送给SQL查询的输入，且能够操纵该输入将其解析为代码而非数据，那么攻击者就有可能有能力在后台数据库上执行该代码。
若应用开发人员无法彻底理解与他们交互的基础数据库或完全无法理解并意识到所开发代码潜在的安全问题，那么他们编写的程序通常是不安全的，容易受到SQL注入攻击。
盲注 假设发现了一个SQL注入点，但应用只提供了一个通用的错误页面，或虽然提供了正常的页面，但与我们取回的内容存在一些可见或不可见的小差异，这些都属于盲注。SQL盲注是指在无法使用详细数据库错误信息或带内数据连接的情况下，利用数据库查询的输入审查漏洞从数据库提取信息或提取与数据库查询相关信息的攻击技术。
强制产生通用错误 应用中经常使用通用错误页面来替换数据库错误，即使出现通用错误页面，也可以推断SQL注入是否可行。若应用只在提交单引号或其中一个变量时才产生通用错误页面，那么很可能存在SQL盲注。提交单引号是最常见的错误源受损的SQL查询。
注入带副作用的查询 最常用的是时序攻击来确认攻击者的SQL是否已执行，有时也可利用攻击者能够观察到的输出进行判断。
拆分与平衡 分解合法输入的操作称为拆分，平衡保证最终查询中不包含不平衡的结尾单引号。
基本思想：收集合法的请求参数，之后使用SQL关键字对他们进行修改以保证与原数据不同，担当数据库解析他们时，二者的功能等价。
基于时间的盲注 所有相应都包含一种属性：发出请求到响应到达这段时间的差异。当某一状态为真时，能够让响应暂停几秒，为假时，能够不出现暂停。
基于响应的盲注 通过仔细检查响应中的数据来推断状态，推断状态时，借助响应中包含的文本或在检查特定值时强制产生的错误，产生的错误类型是运行时错误而非查询编译错误。
常用步骤 （一）发现SQL注入位置 1.整型参数判断 HTTP://xxx.xxx.xxx/xxx.asp?p=xx&#39;，此时xxx.asp中SQL语句变成了select * from 表名 where 字段=xx&#39; ，xx.asp运行异常。
HTTP://xxx.xxx.xxx/xxx.asp?p=xx and 1=1，xxx.asp运行正常，且与HTTP://xxx.xxx.xxx/xxx.asp?p=xx运行结果相同
HTTP://xxx.xxx.xxx/xxx.asp?p=xx and 1=2，xxx.asp运行异常
2.字符型参数判断 HTTP://xxx.xxx.xxx/xxx.asp?p=xx&#39;，此时xxx.asp中的SQL语句变成了select * from 表名 where 字段=xx&#39;，xxx.asp运行异常。
HTTP://xxx.xxx.xxx/xxx.asp?p=xx&amp;amp;nm&amp;hellip;39;1&#39;=&amp;lsquo;1&amp;rsquo;，xxx.asp运行正常，且与HTTP://xxx.xxx.xxx/xxx.asp?p=xx运行结果相同。
HTTP://xxx.xxx.xxx/xxx.asp?p=xx&amp;amp;nb&amp;hellip;39;1&#39;=&amp;lsquo;2&amp;rsquo;，xxx.asp运行异常。
若这三步全满足，则xxx.asp一定存在SQL注入漏洞。
特殊类型参数判断 对于字符过滤等情况，可以尝试以下方法。
大小写混合：VBS不区分大小写，程序员在设计时往往忽略大小写混合情况，可以尝试使用SelecT代替select。
UNICODE：UNICODE字符集实现国际化，+=%2B，space=%20。
ASCII：U=chr(85)，a=chr(97)。
（二）判断后台数据库类型 查询数据库名称 1&amp;#39; union select 1,database(); 查询数据库表名 1&amp;#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database(); 获取字段名 1&amp;#39; union select 1,group_concat(columns_name) from information_schema.</description>
    </item>
    
    <item>
      <title>My 1st post</title>
      <link>https://oopsdc.tk/post/my-1st-post/</link>
      <pubDate>Tue, 15 Sep 2020 11:30:03 +0000</pubDate>
      
      <guid>https://oopsdc.tk/post/my-1st-post/</guid>
      <description>Desc Text.</description>
    </item>
    
    <item>
      <title>Bugku</title>
      <link>https://oopsdc.tk/post/bugku/</link>
      <pubDate>Mon, 13 Apr 2020 22:06:50 +0800</pubDate>
      
      <guid>https://oopsdc.tk/post/bugku/</guid>
      <description>Bugku Web Web1  Des:flag{}。
 查看源码即可。
Web2  Des:输入验证码即可得到flag。
 输入框有输入长度限制，在控制台修改长度即可。
Web3  Des:flag{}。
 通过get传参，按照题目要求直接传入
?what=flagWeb4  Des:post。
 方法1 利用hackbar直接post传参。
方法2 利用burp抓包传值。
方法3 编写python脚本。
import requests s = requests.Session() r = s.get(&amp;#34;&amp;lt;url&amp;gt;&amp;#34;) value = {&amp;#39;what&amp;#39;:&amp;#39;flag&amp;#39;} r = s.post(&amp;#34;&amp;lt;url&amp;gt;&amp;#34;, value) print(r.text) 题目更新  Des:看看源代码吧。
 查看源代码，发现有两串编码字符串。
分别对两个字符串进行URL解码：
按照代码含义将其组合起来：
放到控制台Console里排版：
将if判断里与a.value判等的值输入提交框，提交。
获得flag。
Web5  Des:矛盾。
 $num = $_GET[&amp;#39;num&amp;#39;]; if (!isnumeric($num)) { echo $num; if ($num == 1) echo &amp;#39;flag{********}&amp;#39;; } 利用1a绕过，例：</description>
    </item>
    
    <item>
      <title>攻防世界</title>
      <link>https://oopsdc.tk/post/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</link>
      <pubDate>Fri, 03 Jan 2020 22:06:50 +0800</pubDate>
      
      <guid>https://oopsdc.tk/post/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</guid>
      <description>攻防世界 Web view source  Des:X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。
 查看页面源码。
获得flag。
robots  Des:X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。
 在URL后加上robots.txt，得到一个php页面提示，访问对应php文件。
获得flag。
backup  Des:X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！
 尝试backup.php，无效。
使用御剑扫描后台，得到index.php.bak，输入后下载备份文件，cat查看。
获得flag。
cookie  Des:X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？
 使用burp抓包，得到cookie.php。
继续使用burp抓包，查看Response。
获得flag。
disable_button  Des:N/A。
 页面的flag按钮无响应，猜测被禁用，查看控制台元素。
&amp;lt;input class=&amp;quot;btn btn-default&amp;quot; disabled&amp;gt;
将此处的disabled前三字符删除，按下按钮。
获得flag。
weak_auth  Des:小宁写了一个登陆验证页面，随手就设了一个密码。
 查看源码。
&amp;lt;from class=&amp;quot;form-inline&amp;quot; method=&amp;quot;post&amp;quot; action=&amp;quot;./check.php&amp;quot;&amp;gt;
有一个验证页面，访问它。
页面空白，查看源码，提示。
&amp;lt;!--maybe you need a dictionary--&amp;gt;
这道题或许不需要字典？
尝试御剑扫描，无果。
好的我错了，随机输入用户名和密码，使用burp抓包，response显示用户名必须为admin，初次爆破无果，手动尝试123456，正确&amp;hellip;.如果尝试继续用字典的话还是可以爆出来，只是比较费时间。
获得flag。
simple_php  Des:小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。
 &amp;lt;?php show_source(__FILE__); include(&amp;#34;config.php&amp;#34;); $a = @$_GET[&amp;#39;a&amp;#39;]; $b = @$_GET[&amp;#39;b&amp;#39;]; if ($a == 0 and $a) { echo $flag1; } if (is_numeric($b)) { exit(); } if ($b &amp;gt; 1234) { echo $flag2; } ?</description>
    </item>
    
    
    <item>
      <title>Links</title>
      <link>https://oopsdc.tk/links/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://oopsdc.tk/links/</guid>
      <description>links</description>
    </item>
    
    
    <item>
      <title>Tag</title>
      <link>https://oopsdc.tk/tags/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://oopsdc.tk/tags/</guid>
      <description>tags</description>
    </item>
    
  </channel>
</rss>
